-- -*- mode: lua; encoding: windows-1251 -*-
local get_string = game.translate_string

local random_task = nil

local parent_by_story = {
	[story_ids.Escape_Trader] 				= "trader",				-- Сидорович
	[story_ids.Escape_tutorial_wounded]		= "shustriy",			-- Шустрый
	[story_ids.Escape_novice_lager_volk]	= "wolf",				-- Волк
	[story_ids.esc_kuznetsov]				= "bridge_commander",	-- Кузнецов
	[story_ids.bar_Barman]					= "barman",				-- Бармен
	[story_ids.bar_hunter]					= "hunter",				-- Охотник
	[story_ids.bar_dolg_polkovnik_petrenko]	= "petrenko",			-- Полковник Петренко
	[story_ids.bar_dolg_general_voronin]	= "dolg",				-- Генерал Воронин
	[story_ids.bar_drunk_dolg]				= "drunk_dolg",			-- Бром
	[story_ids.bar_bar_osvedomitel]			= "mercenary",			-- Осведомтель
	[story_ids.bar_zastava_commander]		= "zastava_commander",	-- Сержант Киценко
	[story_ids.bar_lisiy]					= "lisiy",				-- Лысый
	[story_ids.Mil_Lukash]					= "freedom",			-- Лукаш
	[story_ids.yan_general_ecolog]			= "ecolog",				-- Сахаров
	[story_ids.stalker_green_zahar]			= "green",				-- Захар
	[story_ids.otshelnik]					= "otshelnik",			-- Отшельник
	[story_ids.dyak]						= "dyak",				-- Дьяк
	[story_ids.marsh_dan]					= "dan"					-- Дэн
}

local story_by_parent = {}
for sid, parent in pairs(parent_by_story) do
	story_by_parent[parent] = sid
end

local function get_str_count(str)
	local n = 1
	while true do
		local st = str.."_"..tostring(n)
		if get_string(st) ~= st then
			n = n + 1
		else
			return n - 1
		end
	end
	return n
end
local timeout_text_number = get_str_count("tm_timeout_desc")
local defend_lager_add_text_number = get_str_count("tm_defend_lager_add_text")

local return_task_by_type = {
	eliminate_lager	= "return_for_reward",
	defend_lager	= "return_for_reward",
	kill_stalker	= "return_for_reward",
	artefact		= "return_for_reward_bring",
	monster_part	= "return_for_reward_bring",
	find_item		= "return_for_reward_bring"
}

local hash_to_id = {}
local id_to_hash = {}
local ct_to_hash = {}
local hash_to_ct = {}
-- хэш функция для строки (посмотреть литературу, на предмет оптимальной)
function stringhash(str)
	local mpl = 1
	local hash = 0
	for i = 1, string.len(str), 1 do
		local val = string.byte( string.sub(str,i,i) )
		hash = hash+mpl*val
		mpl = mpl*2
		if mpl == 512 then mpl = 1 end
	end
	return bit_and(hash, 65535)
end

class "CRandomTask"
function CRandomTask:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	self.task_ini = ini_file("misc\\task_manager.ltx")
	self.task_phrase_id = 100

	--' Итерируемся по всем настройкам фраз
	if not self.task_ini:section_exist("list") then
		abort("There is no section [list] in task_manager.ltx")
	end

	local n = self.task_ini:line_count("list")
	local result, id, value = "","",""

	--' начальная установка
	self.task_info = {}

	local need_get_ct_hash = not has_alife_info("task_save_fix")												 
	local def_idle_time = 48*60*60

	for i = 0, n-1 do
		result, id, value = self.task_ini:r_line("list",i,"","")
		local hash = stringhash(id)
		if hash_to_id[hash] then
			abort("Collision! Hash:%d id1:%s id2:%s", hash, hash_to_id[hash], id)
		end
		hash_to_id[hash] = id
		id_to_hash[id] = hash
		-- amk.mylog("id:"..id.." hash:"..hash)

		if not self.task_ini:section_exist(id) then
			abort("There is no section [%s] in task_manager.ltx", id)
		end   

		self.task_info[tostring(id)]			= {}
		local curr_task_info					= self.task_info[tostring(id)]
		if not self.task_ini:line_exist(id, "type") then
			abort("Task manager error: no type in section [%s]", id)
		end

		curr_task_info.type			= self.task_ini:r_string(id, "type")			

		curr_task_info.name			= id
		if self.task_ini:line_exist(id, "parent") then
			curr_task_info.parent		= self.task_ini:r_string(id, "parent")
			curr_task_info.complex_type = curr_task_info.type .. "_" .. curr_task_info.parent
		else
			curr_task_info.parent		= "nil"
			curr_task_info.complex_type = curr_task_info.type
		end

        if need_get_ct_hash then
			local ct = curr_task_info.complex_type
			local cthash = stringhash(ct)
			if hash_to_ct[cthash] and hash_to_ct[cthash] ~= ct then
				abort("Collision! Hash:%d ct1:%s ct2:%s", hash,hash_to_ct[hash], ct)
			end
			hash_to_ct[cthash] = ct
			ct_to_hash[ct] = cthash
		end
		if self.task_ini:line_exist(id, "target") then
			curr_task_info.target = self.task_ini:r_string(id, "target")
			if self.task_ini:line_exist(id, "target_count") then
				curr_task_info.target_count = self.task_ini:r_u32(id, "target_count")
			end
		end
		if self.task_ini:line_exist(id, "text") then
			curr_task_info.text			= self.task_ini:r_string(id, "text")
		end
		if self.task_ini:line_exist(id, "description") then
			curr_task_info.description	= self.task_ini:r_string(id, "description")				
		end
		curr_task_info.time				= self.task_ini:r_u32_ex(id, "time")

		curr_task_info.idle_time		= self.task_ini:r_u32_ex(id, "idle_time", def_idle_time) --' Время между выдачами задания (в игровых секундах)
		curr_task_info.prior			= self.task_ini:r_float_ex(id, "prior", 0) --' Приоритет квеста, выдаются доступные квесты с наименьшим приоритетом

		if self.task_ini:line_exist(id, "reward_item") then
			curr_task_info.reward_items = parse_reward_items( self.task_ini:r_string(id, "reward_item") )
		end
		
		curr_task_info.reward_money = self.task_ini:r_u32_ex(id, "reward_money", nil)
		curr_task_info.reward_type = self.task_ini:r_u32_ex(id, "reward_type", nil)
		curr_task_info.reward_count = self.task_ini:r_u32_ex(id, "reward_count", nil)
		curr_task_info.reward_script = self.task_ini:r_string_ex(id, "reward_script", nil)
		-- Награда информацией
		-- amk.mylog("reward info read")
		curr_task_info.reward_info = self.task_ini:r_string_ex(id, "reward_info", nil)
		if curr_task_info.reward_info then
			self:read_info_reward_section(curr_task_info)
		end
		-- amk.mylog("reward info read done")
		-- Диалог для квестовой жертвы
		curr_task_info.target_dialog = self.task_ini:r_string_ex(id, "target_dialog", nil)
		----------------------	

		curr_task_info.reward_rank			= self.task_ini:r_float_ex(id, "reward_rank", 0)
		curr_task_info.reward_reputation	= self.task_ini:r_float_ex(id, "reward_reputation", nil)
		curr_task_info.reward_relation		= parse_key_value( self.task_ini:r_string_ex(id, "reward_relation", "") )

		curr_task_info.condlist				= xr_logic.parse_condlist( Actor, "task_manager", "condlist", self.task_ini:r_string_ex(id, "condlist", "true") )		

		curr_task_info.need_return			= self.task_ini:r_bool_ex(id, "need_return", true)

		curr_task_info.init_phrase_id		= self:gen_phrase_id()
		curr_task_info.desc_phrase_id		= self:gen_phrase_id()
		curr_task_info.yes_phrase_id		= self:gen_phrase_id()
		curr_task_info.no_phrase_id			= self:gen_phrase_id()
		curr_task_info.completed_phrase_id = self:gen_phrase_id()

		--' По умолчанию квест доступен для выдачи
		curr_task_info.enabled				= true
		--' Доступен ли квест по своим свойствам. По умолчанию всегда недоступен.
		--' Этот параметр зависит от наличия целей для квестов и того срабатывает ли прекондишн квеста
		curr_task_info.enabled_props		= false

		--' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
		curr_task_info.status				= "normal"
	end

	--' Создание дополнительных ассоциативных таблиц для облегчения поиска
	self.task_id_by_type = {}
	self.task_id_by_parent = {}
	self.task_id_by_yes_phrase_id = {}
	self.task_id_by_completed_phrase_id = {}
	self.task_id_by_desc_phrase_id = {}
	self.task_id_by_init_phrase_id = {}
	self.active_task_by_type = {}

	for k,v in pairs(self.task_info) do
		--' По типу квеста
		if self.task_id_by_type[v.type] == nil then
			self.task_id_by_type[v.type] = {}
		end
		table.insert(self.task_id_by_type[v.type], k)

		--' По типу вендора
		if self.task_id_by_parent[v.parent] == nil then
			self.task_id_by_parent[v.parent] = {}
		end
		table.insert(self.task_id_by_parent[v.parent], k)

		--' По id фразы согласия на квест
		self.task_id_by_yes_phrase_id[tostring(v.yes_phrase_id)] = k
		self.task_id_by_completed_phrase_id[v.completed_phrase_id] = k
		self.task_id_by_desc_phrase_id[v.desc_phrase_id] = k
		-- amk.mylog("task "..v.complex_type .. " id " .. v.completed_phrase_id)
		--' По id фразы выдачи квеста.
		self.task_id_by_init_phrase_id[tostring(v.init_phrase_id)] = k
	end

	self.protected_smarts = {}
end

--------- Награда информацией --------
function CRandomTask:read_info_reward_section(tbl)
--  amk.mylog("reading section "..sect)
	if tbl.reward_info == nil then return false end

	local section = tbl.reward_info
	local rip = self.task_ini:r_string_ex(section, "info_portion", nil)
	if rip == nil then
		log("! [CRandomTask:read_info_reward_section] Error! Section [%s] not exist in task_manager.ltx or line 'info_portion' not exist in this", section)
		tbl.reward_info = nil
		return false
	else
		tbl.reward_info_portion = se_respawn.parse_names(rip)
	end
	-- проверим, может инфо уже выдано
	local n = 0
	for i, v in ipairs(tbl.reward_info_portion) do
		if has_alife_info(v) then
			n = n + 1
		end
	end
	if n == #tbl.reward_info_portion then
		tbl.reward_info_portion = nil
		tbl.reward_info = nil
	--	log("- CRandomTask:read_info_reward_section: actor already has info for section [%s]", section)
		return false
	end

	tbl.reward_info_dialog={}
	local phr=1
	while true do
		local phrase_id = self.task_ini:r_string_ex(section, "phrase_"..phr, nil)
		if phrase_id == nil then break end
		-- amk.mylog("phrase_"..phr.." is "..phrase_id)
		phr = phr + 1
		table.insert(tbl.reward_info_dialog, phrase_id)
	end
	return true
end
--------------------------------------
--' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
-- Ну и замечательно. Запишем его числом. - семикратная экономия.
local status_to_num = {
	["normal"]		= 0,
	["selected"]	= 1,
	["completed"]	= 2,
	["refused"]		= 3,
	["failed"]		= 4,
	["rewarded"]	= 5
}
local num_to_status={}
for k, v in pairs(status_to_num) do
	num_to_status[v] = k
end

-- Будем записывать не id задания а его хеш - семикратная экономия.
function CRandomTask:save(p)
	if not has_alife_info("task_save_fix") then
		Actor:give_info_portion("task_save_fix")
	end
	-- log("^^^ [CRandomTask:save]")
	--' Считаем количество записей
	local n = table.size(self.task_info)
	p:w_u16(n)
	-- log("tasks: %s", n)
	-- log("active_task_by_type: %s", table.size(self.active_task_by_type))

	for k,v in pairs(self.task_info) do
		if not id_to_hash[k] then
			abort("[CRandomTask:save] Cannot find hash for id %s!", k)
		end
		p:w_u16(id_to_hash[k])

		n = status_to_num[v.status] or abort("[CRandomTask:save] Wrong status '%s' for task %s!", v.status, k)

		if v.enabled then n = bit_or(n, 8) end
		if v.enabled_props then n = bit_or(n, 16) end

		-- selected_target и defend_target сохраняем только если они есть
		-- активен ли таск - сохраняем тут же одним битом
		-- хрен-знает-сколькикратная экономия
		if v.selected_target then n = bit_or(n, 32) end
		if v.defend_target then n = bit_or(n, 64) end
		if self.active_task_by_type[v.complex_type] == k then
			n = bit_or(n, 128)
		end

		p:w_u8(n)

		if v.selected_target then
			p:w_u16(v.selected_target)		-- id, u16
		end
		if v.defend_target then
			p:w_u32(v.defend_target)		-- story_id, u32
		end

		utils.w_CTime(p, v.last_task_time)
	end
end

--' Загрузка
function CRandomTask:load(p)
	if not has_alife_info("task_save_fix") then
		-- log("^^^ [CRandomTask:load_old]")
		self:load_old(p)
		Actor:give_info_portion("task_save_fix")
		return
	end

	-- log("^^^ [CRandomTask:load]")
	--' Считаем количество записей
	-- local rt0=p:r_tell()
	local i = p:r_u16()
	-- log("tasks: %s", i)
	local n, id, hash
	for k = 1, i do
		hash = p:r_u16() 
		id = hash_to_id[hash] or abort("[CRandomTask:load] Cannot find id for hash %d!", hash)
		local t = self.task_info[id] or abort("[CRandomTask:load] Cannot find task for id %s!", id)
		n = p:r_u8()
		t.enabled = bit_and(n, 8)~=0
		t.enabled_props = bit_and(n, 16)~=0

		if bit_and(n, 32) ~= 0 then
			t.selected_target = p:r_u16()
		end
		if bit_and(n, 64) ~= 0 then
			t.defend_target = p:r_u32()
		end
		if bit_and(n, 128) ~= 0 then
			if self.active_task_by_type[t.complex_type] ~= nil then
				abort("[CRandomTask:load] Error with load active task[%s]: task with type '%s' already loaded: %s",
					id, t.complex_type, self.active_task_by_type[t.complex_type])
			end
			self.active_task_by_type[t.complex_type] = id
		end

		n = bit_and( n, bit_not(8+16+32+64+128) )
		t.status = num_to_status[n]
			or abort("[CRandomTask:load] Error with loading task [%s] status: %s", id, n)

		t.last_task_time = utils.r_CTime(p)
	end
	-- log("active_task_by_type: %s", table.size(self.active_task_by_type))
	-- log("data size: %s", p:r_tell()-rt0)
end
--' Загрузка, старый вариант - для совместимости
function CRandomTask:load_old(p)
	-- log("^^^ LOAD")
	--' Считаем количество записей
	-- local rt0=p:r_tell()
	local i = p:r_u8()
	-- log("tasks "..i)
	local v, id, hash
	for k = 1, i do
		hash = p:r_u16() 
		id = hash_to_id[hash] or abort("[CRandomTask:load] Cannot find id for hash %d!", hash)
		local t = self.task_info[id] or abort("[CRandomTask:load] Cannot find task for id %s!", id)
		local f = p:r_u8()
		t.enabled = bit_and(f, 8)~=0
		t.enabled_props = bit_and(f, 16)~=0
		f = bit_and(f, bit_not(8+16))
		t.status = num_to_status[f]

		v = p:r_u16()
		if v ~= 0 then
			t.selected_target = v
		end
		v = p:r_u32()
		if v ~= 0 then
			t.defend_target = v
		end
		t.last_task_time = utils.r_CTime(p)
	end
	--' Та же самая процедура с активными тасками
	i = p:r_u8()  
	-- log("active "..i)
	for k = 1,i do
		v = p:r_u16()
		id = hash_to_ct[v]
			or abort("[CRandomTask:load] Cannot find complex type for hash %d!", v)
		hash = p:r_u16()
		self.active_task_by_type[id] = hash_to_id[hash]
			or abort("[CRandomTask:load] Cannot find task id for hash %d!", hash)
	end
	-- log("size "..tostring((p:r_tell()-rt0)))
end
--' Генератор уникальных ID для фраз
function CRandomTask:gen_phrase_id()
	self.task_phrase_id = self.task_phrase_id + 1
	return tostring(self.task_phrase_id)
end
--' Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent(npc)
	local story_id = npc:story_id()
	if parent_by_story[story_id] == nil then
		abort("[CRandomTask:get_parent] Error: wrong parent story_id[%s]", story_id)
	end
	return parent_by_story[story_id]
end
--' Может ли вендор выдать квест
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
	local parent = self:get_parent(npc)
	local avail = false
	self:task_avail(actor, npc, nil, nil, nil, "reset")
	for k,v in ipairs(self.task_id_by_parent[parent]) do
		if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, true) then
			avail = true
		end
	end
	return avail
end
--' Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task(actor, npc)
	local parent = self:get_parent(npc)
	for k,v in pairs(self.active_task_by_type) do
		-- printf("active_parent_task: %s", tostring(v))
		-- printf("active_parent_task: parent = %s", tostring(self.task_info[v].parent))
		-- printf("active_parent_task: status = %s", tostring(self.task_info[v].status))

		if self.task_info[v].parent == parent and
			(self.task_info[v].status == "selected" or
			self.task_info[v].status == "completed")
		then
			return true
		end       
	end
	return false
end
--' Есть ли игрока завершенные задания (которые осталось только сдать)
function CRandomTask:have_completed_job(actor, npc)
	-- print_table(self.active_task_by_type)
	local parent = self:get_parent(npc)
	for k,v in pairs(self.active_task_by_type) do
		-- printf("have_completed_job: %s", tostring(v))
		-- printf("have_completed_job: parent = %s", tostring(self.task_info[v].parent))
		-- printf("have_completed_job: status = %s", tostring(self.task_info[v].status))

		if self.task_info[v].parent == parent and
			self.task_info[v].status == "completed"
		then
			return true
		end       
	end
	return false
end
--' Выдача квеста игроку
function CRandomTask:action_give_task(actor, npc, p1, p2)
	local task = CGameTask()

	-- printf("p1 = %s p2 = %s", tostring(p1), tostring(p2))

	local task_id=self.task_id_by_yes_phrase_id[p2]
	local task_desc = self.task_info[task_id]

	task:load(task_desc.complex_type)
	task:set_title(get_string(task_desc.type))

	local oo = task:get_objective(0)
	oo:set_article_id(task_desc.description)

	local objective = SGameTaskObjective(task,1)
	objective:set_description(task_desc.name)

	--' Выбираем текущую цель квеста
	if task_desc.target_objects ~= nil then
		self.task_info[task_id].selected_target = table.random( task_desc.target_objects )
		-- printf("TARGET DEBUG INFO")
		-- printf("selected = %s", tostring(self.task_info[self.task_id_by_yes_phrase_id[p2]].selected_target))
		-- print_table(task_desc.target_objects)
	end

	if task_desc.type == "eliminate_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("eliminate_lager_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "defend_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("defend_lager_location")
		objective:set_object_id(task_desc.selected_target)

		local defend_object = AI:object(task_desc.selected_target)
		local sm_ini = defend_object:spawn_ini()
		self.task_info[task_id].defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
	elseif task_desc.type == "kill_stalker" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("kill_stalker_location")
		objective:set_object_id(task_desc.selected_target)
		-- Добавим id сталкера в список целей
		if task_desc.target_dialog then
			amk_add_target_id_to_kill_targets(task_desc.selected_target,task_desc.target_dialog,task_id)
		end
		-------------------------------------
	elseif task_desc.type == "find_item" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("find_item_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "artefact" then	-- выдадим описание артефакта, иначе неизвестно, что надо искать
		artefact_hunter.add_art_info(task_desc.target)
	end

	objective:add_complete_func("task_manager.task_complete")
	task:add_objective(objective)

	if task_desc.need_return then
		objective = SGameTaskObjective(task,2)
		objective:set_description(return_task_by_type[task_desc.type])

		objective:set_map_hint(return_task_by_type[task_desc.type])
		objective:set_map_location("blue_location")
		if not AI:story_object(tonumber(story_by_parent[task_desc.parent])) then
			-- Квестодателя прибили.
			return 
		end
		objective:set_object_id(AI:story_object(tonumber(story_by_parent[task_desc.parent])).id)
		task:add_objective(objective)
	end

	local time = 0
	if task_desc.time ~= nil then
		local title_time = game.CTime()
		title_time:setHMS(0,0,task_desc.time)
		title_time:add(game.get_game_time())
		task:set_title(task:get_title().."\\n%c[255,150,150,180]до "..title_time:dateToString(game.CTime.DateToDay))

		time = task_desc.time * 1000
		amk.save_variable("tm"..tostring(id_to_hash[task_desc.name]), math.ceil(game_time_minutes + task_desc.time/60))
	end
	Actor:give_task(task,time,false)

	--' дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
	self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "selected"
	self.active_task_by_type[task_desc.complex_type] = self.task_id_by_yes_phrase_id[p2]
	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = false
		end
	end
end
--' Отказ игроком от квеста
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
	local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]

	--' Делаем доступными все задания данного типа
	task_desc.status = "refused"
	-- Удаляем цель из списка 
	amk_remove_target_id_from_kill_targets(task_desc.selected_target)
	-------------------------
	task_desc.selected_target = nil
	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = true
		end
	end
end
--' Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1, p2)
	if Actor == nil then
		return false
	end

	local sel_task = self.task_info[self.active_task_by_type[p1]]
	if sel_task == nil then
		log("!!!CRandomTask:task_complete failed: current task is nil")
		table.print(self.active_task_by_type)
		log("!!!")
		table.print(self.task_info)
		-- abort("WRONG RANDOM TASK %s %s", tostring(p1), tostring(p2))
		return false
	end

	if p2 == 0 then
		if not sel_task.need_return and sel_task.status == "completed" then
			sel_task.last_task_time = game.get_game_time()
			return true
		end
		if sel_task.status == "rewarded" then
			sel_task.last_task_time = game.get_game_time()
			return true
		end
	end

	if p2 == 1 then
		if sel_task.type ==	"eliminate_lager" then
			local oo = AI:object(sel_task.selected_target)
			if oo and oo.gulag:get_population_comed() == 0 then
				sel_task.status = "completed"
				return true
			end
		elseif sel_task.type ==	"defend_lager" then
			--' Квест выполнен потому что рейд прекратился
			if xr_gulag.getGulagState(sel_task.defend_target) == 0 then
				sel_task.status = "completed"
				return true
			end
		elseif sel_task.type ==	"kill_stalker" then
			local oo = AI:object(sel_task.selected_target)

			--' Проверка бага
			if oo == nil then
				printf("selected_target = %s", tostring(sel_task.selected_target))
				abort("OBJ = nil for task %s", tostring(self.active_task_by_type[p1]))
			elseif oo.alive == nil then 
				printf("OBJ.ALIVE = nil for task %s", tostring(self.active_task_by_type[p1]))
				abort("OBJ.NAME = %s", obj:name())        
			end   

			if oo and oo:alive() == false then
				-- Сталкер убит. Удаляем его ид из списка  целей
				amk_remove_target_id_from_kill_targets(sel_task.selected_target)
				-------------------------------------------------
				sel_task.status = "completed"
				return true
			end
		elseif sel_task.type == "artefact"
			or sel_task.type == "monster_part"
			or sel_task.type == "find_item"
		then
			if inventory.search(sel_task.target, sel_task.target_count) then
				sel_task.status = "completed"
				return true
			end
		end
	end
  
	return false
end
--' Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1, p2)
	if p2 == 0 then
		local sel_task = self.task_info[self.active_task_by_type[p1]]

		if sel_task == nil then
			printf("!!!")
			print_table(self.active_task_by_type)
			printf("!!!")
			print_table(self.task_info)
			-- abort("WRONG RANDOM TASK %s %s", tostring(p1), tostring(p2))
			return false
		end

		--' Проверяем что жив, выдавший квест.
		local parent = AI:story_object(story_by_parent[sel_task.parent])
		if parent == nil or (parent.alive ~= nil and not parent:alive()) then
			sel_task.status = "failed"
			sel_task.last_task_time = game.get_game_time()
			return true   
		end

		if sel_task.status == "refused" or sel_task.status == "failed" then
			sel_task.last_task_time = game.get_game_time()
			return true
		end
		if sel_task.type == "defend_lager" then
			if AI:object(sel_task.selected_target).gulag:get_population_comed() == 0 then
				sel_task.status = "failed"
				sel_task.last_task_time = game.get_game_time()
				return true
			end
		end
	end
	return false
end

--' Обнуление переменных при завершении или провале таска
function CRandomTask:task_callback(p1, p2, state)
	if p2 ~= 0 then
		return
	end

	local task_id = self.active_task_by_type[p1]
	if task_id == nil then
		return
	end

	-- Удаляем цель из списка
	local task_info = self.task_info[task_id]
	if task_info and task_info.selected_target then
		amk_remove_target_id_from_kill_targets(task_info.selected_target)
	end
	----------------------------------

	if state == task.completed
		or state == task.fail
	then
		task_info.status = "normal"
		--' восстановление других заданий данного типа
		for i, v in ipairs(self.task_id_by_parent[task_info.parent]) do
			if self.task_info[v].complex_type == p1 then
				self.task_info[v].enabled = true
			end
		end
		self.active_task_by_type[p1] = nil
		amk.del_variable("tm"..tostring(id_to_hash[task_info.name]))
	end
end
--' Выводит список доступных квестов
function CRandomTask:action_task_show(npc, actor)
	local parent = self:get_parent(npc) 
	for k,v in ipairs(self.task_id_by_parent[parent]) do
		local task_desc = self.task_info[v]
		if self:task_avail(actor, npc, nil, nil, task_desc.init_phrase_id, false) then
			local task_texture, task_rect = get_texture_info("ui_iconsTotal_"..task_desc.type, "ui_iconsTotal_stalker10")
			Actor:give_talk_message(get_string(task_desc.name), task_texture, task_rect,"iconed_trade_info")
		end
	end
end
--' Проверка доступен ли текущий таск для выдачи
function CRandomTask:task_avail(actor, npc, p1, p2, p3, calculate)
	local task_desc = self.task_info[self.task_id_by_init_phrase_id[p3]]
	--' Если calculate == true то нужно проверять check_task_props, инача просто вернуть значения.
	if calculate == "reset" then    
		self.current_parent_type_prior = {}
		return
	elseif calculate == true then
		self:check_task_props(self.task_id_by_init_phrase_id[p3])

		local t = task_desc.enabled and task_desc.enabled_props

		--' Устанавливать обрезания по приоритетам тут.
		if t == true and (self.current_parent_type_prior[task_desc.complex_type] == nil or
			self.current_parent_type_prior[task_desc.complex_type] > task_desc.prior )
		then
			self.current_parent_type_prior[task_desc.complex_type] = task_desc.prior
		end

		return t
	end

	--' printf("@@@prior %s -> %s [%s]", task_desc.complex_type, task_desc.prior, tostring(calculate))
	--' print_table(self.current_parent_type_prior)

	if self.current_parent_type_prior[task_desc.complex_type] ~= nil and
		self.current_parent_type_prior[task_desc.complex_type] < task_desc.prior
	then
		return false
	end

	--' printf("@@@avail %s", tostring(self.task_id_by_init_phrase_id[p3]))
	--' printf("@@@enabled %s", tostring(self.task_info[self.task_id_by_init_phrase_id[p3]].enabled))
	--' printf("@@@enabled_props %s", tostring(self.task_info[self.task_id_by_init_phrase_id[p3]].enabled_props))

	return task_desc.enabled and 
		task_desc.enabled_props
end
--' Проверка свойств таска
function CRandomTask:check_task_props(task_id)
	local task_desc = self.task_info[task_id]
	--' Проверка по активным заданиям данного типа у вендора.
	if self.active_task_by_type[task_desc.complex_type] ~= nil then
		task_desc.enabled_props = false
		return
	end

	--' Проверка по кондлисту
	if xr_logic.pick_section_from_condlist(Actor, Actor, task_desc.condlist) == nil then
		task_desc.enabled_props = false
		return
	end

	--' Проверка по таймауту
	if task_desc.last_task_time ~= nil and
		game.get_game_time():diffSec(task_desc.last_task_time) < task_desc.idle_time
	then
		task_desc.enabled_props = false
		return
	end

	--' проверка по таргету
	if task_desc.type == "eliminate_lager" then
		if task_desc.target_objects == nil then
			task_desc.enabled_props = false
			return
		end
		for k,v in ipairs(task_desc.target_objects) do
			local gulag = AI:object(v).gulag
			if gulag:get_population_comed() > 0 then
				task_desc.enabled_props = true
				return 
			end
		end
		task_desc.enabled_props = false
		return
	elseif task_desc.type == "defend_lager" then
		if task_desc.target_objects == nil then
			task_desc.enabled_props = false
			return
		end
		for k,v in ipairs(task_desc.target_objects) do
			local defend_object = AI:object(v)
			local sm_ini = defend_object:spawn_ini()
			local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
			if xr_gulag.getGulagState(defend_target) == 1 then
				task_desc.enabled_props = true
				return
			end
		end
		task_desc.enabled_props = false
		return
	elseif task_desc.type == "kill_stalker" then
		if task_desc.target_objects == nil then
			task_desc.enabled_props = false
			return
		end
		for k,v in ipairs(task_desc.target_objects) do
			local obj = AI:object(v)

			--' Проверка бага
			if obj ~= nil and obj.alive == nil then 
				printf("OBJ.ALIVE = nil for task %s", task_id)
				print_table(task_desc.target_objects)
				abort("OBJ.NAME = %s", obj:name())        
			end     

			if obj ~= nil and
				obj:alive() == true 
			then
				task_desc.enabled_props = true
				return
			else
				table.remove(task_desc.target_objects, k)
			end
		end
		task_desc.enabled_props = false
		return
	elseif task_desc.type == "find_item" then
		if task_desc.target_objects == nil or #task_desc.target_objects == 0 then
			task_desc.enabled_props = false
			return
		end
		for k,v in pairs(task_desc.target_objects) do
			local obj = AI:object(v)
			if obj ~= nil then
				--' Нужно игнорировать предметы, которые находяться у вендоров.
				if obj.parent_id ~= nil then
					for kk,vv in pairs(parent_by_story) do
						local parent = AI:story_object(kk)
						if parent ~= nil and obj.parent_id == parent.id then
							--' Игнорим предмет
							task_desc.enabled_props = false
							return              
						end
					end
				end

				task_desc.enabled_props = true
				return
			end 
			task_desc.enabled_props = false
			return
		end
	else
		task_desc.enabled_props = true
		return    
	end
end
--' Проверяется является ли текущий таск выданным игроку
function CRandomTask:active_task(actor, npc, p1, p2, p3)
	local status = self.task_info[self.task_id_by_init_phrase_id[p3]].status
	return status == "selected" or status == "completed"
end

function CRandomTask:make_task_failed(task_id)
	if self.task_info[task_id] then
		self.task_info[task_id].status="failed"
	end
end

-- Проверяется наличие квестовых предметов
function CRandomTask:completed_task(actor, npc, p1, p2, p3)
	-- amk.mylog("Checking quest items p1 "..tostring(p1).." p2 "..tostring(p2).." p3 "..tostring(p3))
	if not p3 then return false end
	-- amk.mylog("chp1")
	local tid = self.task_id_by_desc_phrase_id[p2]
	-- amk.mylog("chp2")
	if not tid then return false end
	-- amk.mylog("chp3")
	local task_desc = self.task_info[tid]
	-- amk.mylog("chp4")
	if task_desc.status ~= "completed" then return false end
	-- amk.mylog("chp5")
	if task_desc.type == "artefact"
		or task_desc.type == "monster_part"
		or task_desc.type == "find_item"
	then
		return inventory.search(task_desc.target, task_desc.target_count)
	end
--  amk.mylog("can finish " .. tostring(can_finish))
	return true
end

--' Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_seek_new_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_list_job","1","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")

	phr = dlg:AddPhrase("tm_"..parent.."_has_no_job","2","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")

	for k,v in ipairs(self.task_id_by_parent[parent]) do
		local task_desc = self.task_info[v]
		phr = dlg:AddPhrase(self.task_info[v].name, tostring(task_desc.init_phrase_id), "1", -10000)		
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")

		phr = dlg:AddPhrase(self.task_info[v].text, tostring(task_desc.desc_phrase_id), tostring(task_desc.init_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.show_reward")

		phr = dlg:AddPhrase("tm_seek_job_yes", tostring(task_desc.yes_phrase_id), tostring(task_desc.desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")

		phr = dlg:AddPhrase("tm_seek_job_no", tostring(task_desc.no_phrase_id), tostring(task_desc.desc_phrase_id), -10000)
	end

	dlg:AddPhrase("tm_seek_job_abandon","3","1",-10000)
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные квесты
function CRandomTask:task_reward(npc, actor, p1, p2)
	-- amk.mylog("Rewarding p1 "..tostring(p1).." p2 "..tostring(p2))
	local parent = self:get_parent(npc) 
	local v = self.task_id_by_completed_phrase_id[p2]
	-- amk.mylog("Rewarding ")

	local task_desc = self.task_info[v]
    if task_desc.status == "completed" and task_desc.parent == parent then
		--' Забираем у игрока квестовый предмет.
		local can_finish = true
		if task_desc.type == "artefact"
			or task_desc.type == "monster_part"
			or task_desc.type == "find_item"
		then
			if inventory.search(task_desc.target, task_desc.target_count) then
				shiftCheckDropItem()
				inventory.out_items(task_desc.target, task_desc.target_count or 1)
			else
				can_finish = false
			end
		end

		if can_finish == true then
			task_desc.status = "rewarded"

			if game_options.RndReward then
				create_reward_rnd(self.task_ini, task_desc)
			else
				if task_desc.reward_money ~= nil then
					dialogs.relocate_money(npc, task_desc.reward_money, "in")
				end
				if task_desc.reward_items ~= nil then
					create_reward(task_desc.reward_items)
				end
			end

			if task_desc.reward_reputation ~= nil then
				Actor:change_character_reputation(task_desc.reward_reputation)
			end

			if task_desc.reward_relation ~= nil then
				for kk,vv in pairs(task_desc.reward_relation) do
					relation_registry.change_community_goodwill (kk, Actor:id(), tonumber(vv))
				end
			end

			if task_desc.reward_rank ~= nil then
				xr_statistic.add_actor_rank(task_desc.reward_rank*2)
			end

			if task_desc.reward_script ~= nil then
				_G.task_manager[task_desc.reward_script]()
			end

			if return_task_by_type[task_desc.type] then
				actor_stats.add_points("quests", task_desc.name, 1, 1)
				archievements.acv_count_3event("acv_ct", 500, "Наёмник", "acv_ct2", 1000, "Стаханов", "acv_ct3", 2000, "Папа Карло")
			end
		end
	end
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные сторилайновые квесты
function CRandomTask:task_reward_storyline(task)
	local task_desc = self.task_info[task:get_id()]
	if task_desc == nil or task_desc.type ~= "storyline" then
		return
	end

	if task_desc.reward_reputation ~= nil then
		Actor:change_character_reputation(task_desc.reward_reputation)
	end

	if task_desc.reward_relation ~= nil then
		for kk,vv in pairs(task_desc.reward_relation) do
			relation_registry.change_community_goodwill (kk, Actor:id(), tonumber(vv))
		end
	end

	if task_desc.reward_rank ~= nil then
		-- actor_stats.add_points("quests", task_desc.name, task_desc.reward_rank, 1)
		xr_statistic.add_actor_rank(task_desc.reward_rank*4)
	end
end
--' Создается диалог актера, в котором будут приниматься задания
function CRandomTask:init_reward_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_reward_job","0","",-10000)
	local phrase_script
	-- amk.mylog("Creating reward dialog")
      
	phr = dlg:AddPhrase("tm_"..parent.."_job_ask", "2", "0", -10000)
  
	-- Список возможных квестов трейдера.
	for k,v in ipairs(self.task_id_by_parent[parent]) do
		local task_desc = self.task_info[v]

		phr = dlg:AddPhrase(task_desc.name, tostring(task_desc.init_phrase_id), "2", -10000)
		phrase_script = phr:GetPhraseScript()   
		phrase_script:AddPrecondition("task_manager.precondition_active_task")

		phr = dlg:AddPhrase("tm_"..parent.."_job_what", tostring(task_desc.desc_phrase_id), tostring(task_desc.init_phrase_id), -10000)

		phr = dlg:AddPhrase("tm_job_refuse", tostring(task_desc.yes_phrase_id), tostring(task_desc.desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_refuse_task")
		phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")

		phr = dlg:AddPhrase("tm_job_nothing", tostring(task_desc.no_phrase_id), tostring(task_desc.desc_phrase_id),-10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_notcompleted_task")

		phr = dlg:AddPhrase("tm_job_completed", tostring(task_desc.completed_phrase_id), tostring(task_desc.desc_phrase_id),-10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_task_reward")
		phrase_script:AddPrecondition("task_manager.precondition_completed_task")

		if task_desc.reward_info then
			local phrcnt = #task_desc.reward_info_dialog
			if phrcnt == 0 then
				for i = 1, #task_desc.reward_info_portion do
					phrase_script:AddGiveInfo(task_desc.reward_info_portion[i])
				end
			else
				-- Добавляем фразу. на случай наличия инфопорции. Иначе вылетит.
				phr = dlg:AddPhrase("...", self:gen_phrase_id(), tostring(task_desc.completed_phrase_id), -10000)
				phrase_script = phr:GetPhraseScript()
				-- phrase_script:AddHasInfo(self.task_info[v].reward_info_portion)        
				for i = 1, #task_desc.reward_info_portion do
					phrase_script:AddHasInfo(task_desc.reward_info_portion[i])
				end

				local prid = tostring(task_desc.completed_phrase_id)
				local first = true
				-- Добавляем диалог
				for i,p in ipairs(task_desc.reward_info_dialog) do
					local cid = self:gen_phrase_id()
					phr = dlg:AddPhrase(p, cid, prid, -10000)
					prid = cid
					if first then
						first = false
						phrase_script = phr:GetPhraseScript()
						for i = 1, #task_desc.reward_info_portion do
							phrase_script:AddGiveInfo(task_desc.reward_info_portion[i])
							phrase_script:AddDontHasInfo(task_desc.reward_info_portion[i])        
						end
					end
				end
			end
		end
	end
	-- amk.mylog("Done")
end
--' Регистрация целей для квестов.
function CRandomTask:register_target(obj)
	if IAmAStalker[obj:clsid()] then
		--' Возможно регистрируется цель для квеста "убить сталкера"
		if not (obj.alive ~= nil and obj:alive() == true) then
			return
		end
		if obj:can_switch_online() == false then return end
		local t
		for k,v in ipairs(self.task_id_by_type["kill_stalker"]) do
			t = self.task_info[v]
			if obj:profile_name() == t.target then
				if t.target_objects == nil then
					t.target_objects = {}
				end
				-- printf("@@@register new target %s[%s] for task %s", obj:name(), obj.id, v)
				table.insert(t.target_objects, obj.id)
			end
		end

	elseif obj:clsid() == clsid.smart_terrain then
		--' Возможно регистрируется цель для квеста "вынести лагерь"
		local t
		for k,v in ipairs(self.task_id_by_type["eliminate_lager"]) do
			t = self.task_info[v]
			if obj:name() == t.target then
				if t.target_objects == nil then
					t.target_objects = {}
				end
				table.insert(t.target_objects, obj.id)
				self.protected_smarts[t.target] = v
			end
		end
		--' Либо регистрируется цель для квеста "защитить лагерь"
		for k,v in ipairs(self.task_id_by_type["defend_lager"]) do
			t = self.task_info[v]
			if obj:name() == t.target then
				--' Проверка что в кастом дате указано от кого защищать
				local sm_ini = obj:spawn_ini()
				local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
				if t.target_objects == nil then
					t.target_objects = {}
				end
				table.insert(t.target_objects, obj.id)
				self.protected_smarts[t.target] = v
				local sobj = AI:story_object(defend_target)
				if sobj then
					self.protected_smarts[sobj:name()] = v
				end
			end
		end

	else
		--' Возможно регистрируется цель для квеста "найти предмет"
		local t
		for k,v in ipairs(self.task_id_by_type["find_item"]) do
			t = self.task_info[v]
			if obj:section_name() == t.target then
				if t.target_objects == nil then
					t.target_objects = {}
				end
				table.insert(t.target_objects, obj.id)
			end       
		end
	end
end
--' Отрегистрация целей для квестов.
function CRandomTask:unregister_target(obj)
	if IAmAStalker[obj:clsid()] then
		local obj_id = obj.id
		--' Возможно отрегистрируется цель для квеста "убить сталкера"
		for k,v in pairs(self.task_id_by_type["kill_stalker"]) do
			local t = self.task_info[v].target_objects
			if t ~= nil then
				for i = 1, #t do
					if t[i] == obj_id then
						table.remove(t, i)
						break
					end
				end     
			end
		end
	elseif obj:clsid() ~= clsid.smart_terrain then
		--' Возможно отрегистрируется цель для квеста "найти предмет"
		local obj_id = obj.id
		for k,v in ipairs(self.task_id_by_type["find_item"]) do
			local t = self.task_info[v].target_objects
			if t ~= nil then
				for i = 1, #t do
					if t[i] == obj_id then
						table.remove(t, i)
						break
					end
				end    
			end
		end
	end
end

--' Напоминания
local show_time_limit = 6*60 	-- game minutes
local parent_names = {}
function CRandomTask:remind()
	if not game_options.RemindTaskMgr then
		return false
	end

	local parent, sid, task_desc, txt_desc, time_str
	local str = ""
	local level_id = AI:level_id()
	local tmp = {}
	for k,v in pairs(self.active_task_by_type) do
		task_desc = self.task_info[v]

		if task_desc.status == "selected"
			or task_desc.status == "completed"
		then
			sid = tonumber(story_by_parent[task_desc.parent])
			parent = AI:story_object(sid)
			if parent
				and ( parent:clsid() == clsid.script_trader
				or parent:alive() )
			then
				local need_show = false
				local time_str = ""
				if task_desc.status == "completed"
					and GGraph:vertex(parent.m_game_vertex_id):level_id() == level_id
				then
					need_show = true
			
				elseif task_desc.status == "selected"
					and ( task_desc.type == "eliminate_lager"
					or task_desc.type == "defend_lager"
					or task_desc.type == "kill_stalker" )
					and task_desc.selected_target
					and AI:object(task_desc.selected_target)
					and GGraph:vertex( AI:object(task_desc.selected_target).m_game_vertex_id ):level_id() == level_id
				then
					need_show = true

				end

				if task_desc.time then
					local m = amk.load_variable("tm"..tostring(id_to_hash[task_desc.name]), nil)
					if m then
						m = m - game_time_minutes
						if m < show_time_limit then
							local h = math.floor(m/60)
							m = m%60
							--local d = math.floor(h/24)
							--h = h%24
							time_str = " (осталось"..
							--	(d > 0 and " "..tostring(d).."дн." or "")..
								(h > 0 and " "..tostring(h).."ч." or "")..
								(m > 0 and " "..tostring(m).."мин." or "")..
								")"
							need_show = true
						end
					end
				end

				if need_show then
					if not parent_names[sid] then 
						parent_names[sid] = reminder.get_npc_name(parent)
					end
					if task_desc.status == "completed"
						and ( task_desc.type == "eliminate_lager"
						or task_desc.type == "defend_lager"
						or task_desc.type == "kill_stalker" )
					then
						txt_desc = return_task_by_type[task_desc.type]
					else
						txt_desc = task_desc.name
					end

					str = str..
						"%c[green_blue]"..parent_names[sid]..
						" > %c[green_blue_light2]"..get_string(task_desc.type)..
						": %c[default]"..get_string(txt_desc)..time_str.."\\n"
				end
			end
		end
	end

	-- Выдаем напоминания
	if #str > 0 then
		reminder.send_info(str)
		return true
	end

	return false
end

function CRandomTask:smart_is_protected(sm)
	local v = self.protected_smarts[sm:name()]
	return v ~= nil and self.task_info[v].status == "selected"
end


function get_random_task()
	if random_task == nil then
		random_task = CRandomTask()
	end
	return random_task
end

function init_trader_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "freedom")
end
function init_shustriy_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "shustriy")
end
function init_lisiy_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "lisiy")
end
function init_hunter_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "hunter")
end
function init_drunk_dolg_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "drunk_dolg")
end
function init_petrenko_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "petrenko")
end
function init_wolf_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "wolf")
end
function init_zastava_commander_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "zastava_commander")
end
function init_mercenary_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "mercenary")
end
function init_green_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "green")
end
function init_bridge_commander_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "bridge_commander")
end
function init_otshelnik_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "otshelnik")
end
function init_dyak_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "dyak")
end
function init_dan_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "dan")
end

function init_trader_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "freedom")
end
function init_shustriy_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "shustriy")
end
function init_lisiy_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "lisiy")
end
function init_hunter_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "hunter")
end
function init_drunk_dolg_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "drunk_dolg")
end
function init_petrenko_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "petrenko")
end
function init_wolf_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "wolf")
end
function init_zastava_commander_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "zastava_commander")
end
function init_mercenary_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "mercenary")
end
function init_green_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "green")
end
function init_bridge_commander_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "bridge_commander")
end
function init_otshelnik_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "otshelnik")
end
function init_dyak_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "dyak")
end
function init_dan_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "dan")
end

function has_active_vendor_task(actor, npc)
	return get_random_task():active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
	return get_random_task():task_avail(actor, npc, p1, p2, p3, false)
end
function precondition_active_task(actor, npc, p1, p2, p3)
	return get_random_task():active_task(actor, npc, p1, p2, p3)
end
function precondition_completed_task(actor, npc, p1, p2, p3)
	return get_random_task():completed_task(actor, npc, p1, p2, p3)
end
function precondition_notcompleted_task(actor, npc, p1, p2, p3)
	return not get_random_task():completed_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_can_task(npc, actor, p1, p2, p3)
	return get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
	return not get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
	return get_random_task():have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
	return not get_random_task():have_completed_job(actor, npc)
end

function action_task_show(npc, actor)
	get_random_task():action_task_show(npc, actor)
end
function action_give_task(actor, npc, p1, p2)
	get_random_task():action_give_task(actor, npc, p1, p2)
end
function action_refuse_task(npc, actor, p1, p2)
	get_random_task():action_refuse_task(npc, actor, p1, p2)
end
function action_task_reward(actor, npc, p1, p2)
	get_random_task():task_reward(npc, actor, p1, p2)
end
function reward_by_task(task) 
	get_random_task():task_reward_storyline(task)
end

function task_complete(p1, p2)
	return get_random_task():task_complete(p1, p2)
end
function task_fail(p1, p2)
	return get_random_task():task_fail(p1, p2)
end
function task_callback(p1, p2, state)
	return get_random_task():task_callback(p1, p2, state)
end

function save(p)
	get_random_task():save(p)
end
function load(p)
	get_random_task():load(p)
end
function clear_task_manager()
	random_task = nil
end

function amk_add_target_id_to_kill_targets(id,dialog,task_id)
	local targets=amk.load_table("kill_targets")
	targets[#targets+1] = {id=id,dialog=dialog,task_id=task_id}
	amk.save_table("kill_targets",targets)
end

function amk_remove_target_id_from_kill_targets(id)
	local targets=amk.load_table("kill_targets")
	for n,v in pairs(targets) do
		if v.id==id then
			table.remove(targets,n)
			break
		end
	end
	amk.save_table("kill_targets",targets)
end

function amk_kill_targets()
	return amk.load_table("kill_targets")
end

function make_task_failed(task_id)
	get_random_task():make_task_failed(task_id)  
end

function show_reward(actor,npc,p1,p2)
	local mgr = get_random_task()
	local task_details = mgr.task_info[mgr.task_id_by_init_phrase_id[tostring(p2-1)]]
	
	if task_details == nil then return end
	
	local timer_text
	if task_details.time then
		local tm = math.floor(task_details.time/3600)
		local tmr
		if tm > 48 then
			tm = math.floor(tm/24)
			tmr = tostring(tm)..naxac.declension(tm, " день", " дня", " дней")
		else
			tmr = tostring(tm)..naxac.declension(tm, " час", " часа", " часов")
		end
		timer_text = format_text_pairs(
			get_string( "tm_timeout_desc_"..tostring( math.random(timeout_text_number) ) ),
			{timer = tmr}
		)
		if task_details.type == "defend_lager" then
			timer_text = timer_text.."\\n"..get_string( "tm_defend_lager_add_text_"..tostring( math.random(defend_lager_add_text_number) ) )
		end
	end
	if game_options.RndReward then
		if timer_text then
			Actor:give_talk_message(timer_text, "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
		end
		return
	end
	
	local reward_items = format_reward_text(task_details.reward_items)
	local reward_money = task_details.reward_money
	if (not reward_items) and (not reward_money) then
		if timer_text then
			Actor:give_talk_message(timer_text, "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
		end
		return
	end

	local reward_text = get_string( "tm_reward_desc_"..tostring( math.random(1, 7) ) )
	Actor:give_talk_message(
		(timer_text and timer_text.." " or  "")..reward_text,
		"ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item"
	)
	
	if reward_items then
		local task_texture, task_rect = get_texture_info("ui_iconsTotal_find_item")
		Actor:give_talk_message(reward_items, task_texture, task_rect,"iconed_trade_info")
	end
	
	if reward_money then 
		local task_texture, task_rect = get_texture_info("ui_iconsTotal_found_money")
		if task_details.need_return and reward_items == "" then
			Actor:give_talk_message(reward_money .. " RU (" .. get_string("return_for_reward") .. ")", task_texture, task_rect, "iconed_trade_info")
		else
			Actor:give_talk_message(reward_money .. " RU", task_texture, task_rect,"iconed_trade_info")
		end
	end
end

function format_reward_text(reward_list)
	if reward_list == nil then return nil end

	local reward_text = ""
	local n
	for k, v in pairs(reward_list) do
		n = v>1 and " x"..tostring(v) or ""
		reward_text = reward_text .. get_string( artefact_hunter.get_art_name(k, true) ) .. n .. ", "
	end

	return string.sub(reward_text, 1, -3)
end

function create_reward(t)
	local task_texture, task_rect = get_texture_info("ui_iconsTotal_found_thing")
	local news_text = "%c[green]"..get_string("general_in_item").."\\n".."%c[default]"
	local txt
	for k,v in pairs(t) do
		for i=1,v do
			AI:create(k, vector(), 0, 0, 0)
		end
		txt = news_text..get_string( artefact_hunter.get_art_name(k,true) )..( v>1 and "%c[gray2] x"..tostring(v) or "" )
		if Actor:is_talking() then
			Actor:give_talk_message(txt, task_texture, task_rect, "iconed_answer_item")
		end
		Actor:give_game_news(txt, task_texture, task_rect, 0, 5000)
	end
end

function parse_reward_items( str )
	local ret = {}
	local cur_sect
	for s in string.gfind( str, "[_%w%-%.]+" ) do
		if cur_sect then
			if tonumber(s) then
				table.add(ret, cur_sect, tonumber(s))
				cur_sect = nil
			else
				table.add(ret, cur_sect)
				cur_sect = s
			end
		else
			cur_sect = s
		end
	end
	if cur_sect then
		table.add(ret, cur_sect)
	end
	return ret
end

function create_reward_rnd(ini, task_desc)
	local reward_type = task_desc.reward_type
	if reward_type == nil then
		reward_type = math.random(1,3)
	end
	local reward_count = task_desc.reward_count
	if reward_count == nil then
		reward_count = math.ceil( math.random(1, 5)/reward_type )
	end

	local section = "reward_"..tostring(reward_type)
	if not ini:section_exist(section) then
		abort("[task_manager.create_reward_rnd]: unknown reward_type '%s' for task [%s]", tostring(reward_type), task_desc.name)
		return
	end

	local n = ini:line_count(section) - 1
	local res, id, val
	local tmp = {}
	while reward_count > 0 do
		res, id, val = ini:r_line(section, math.random(0, n), "", "")
		if id and id ~= "" then
			if task_desc.type ~= "artefact"
				or not isArtefact( nil, sys_ini:r_clsid(id, "class") )
			then
				table.add(tmp, id)
				reward_count = reward_count - 1
			end
		end
	end

	create_reward(tmp)

	if task_desc.reward_money ~= nil or math.random() > 0.7 then
		aem_manager.manage_money(math.random(10, 50)*100, "in")
	end
end

-- функции наград
function bad_day()
	if not has_alife_info("bad_day_showed") then
		Actor:give_info_portion("bad_day_showed")
		game.start_tutorial("bad_day")
	end
end
function dar_teleport()
	if not has_alife_info("darkscape_ruck_spawned") then
		Actor:give_info_portion("darkscape_ruck_spawned")
		AI:create( "dar_tele_ao_1", vector():set(266.32308959961,7.5834002494812,642.74664306641),719591,4157)
		AI:create( "dar_tele_ao_2", vector():set(245.40814208984,-2.8979489803314,678.97473144531),687469,4157)
		AI:create_no_ai( "dar_ao_ruk", vector():set(241.66676330566,-2.8526253700256,672.17962646484),913093,4144)
	end
end
