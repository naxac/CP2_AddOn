-- -*- mode: lua; encoding: windows-1251 -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

local table_sort = table.sort
local table_remove = table.remove
local math_random = math.random
local math_floor = math.floor
local math_abs = math.abs
local math_ceil = math.ceil
local string_find = string.find

off_npcs={}
items={}
local no_sell_table = {}

local wpn_fp = {}
-- Пора апдейт делать
local bFlag = false
-- Номер последнего отработанного обьекта
local iCounter = 1
-- Время последнего глобального апдейта
local iTime = -1
-- Как часто делать апдейты, игровые минуты
local iFreq = 60

local monster_params = {}

local maps={
	"l01_escape",
	"l02_garbage",
	"l03_agroprom",
--	"l03u_agr_underground",
	"l04_darkvalley",
--	"l04u_labx18",
	"l05_bar",
	"l06_rostok",
	"l07_military",
	"l08_yantar",
	--"l08u_brainlab",
	"l10_radar",
	--"l10u_bunker",
	"l11_pripyat",
	--"l12_stancia",
	--"l12_stancia_2",
	--"l12u_control_monolith",
	--"l12u_sarcofag"
	"marsh",
	"atp_for_test22",
	"limansk",
	"red_forest"
}

protected = {
	names = {},		-- имена объектов (стоит добавлять только уникальные имена!)
	ids = {},		-- ID объектов
	story_ids = {	-- story ID объектов
	5008,
	5013,
	5014,
	5041,
	5065,
	5084,
	5104,
	5205,
	5222,
	5226,
	5237,
	5238,
	5243,
	5244,
	5245,
	5246,
	5247,
	5248,
	5249,
	5250,
	5254,
	5255,
	5408,
	5413,
	5428,
	5433,
	5434,
	5444,
	5446,
	5470,
	5471,
	5472,
	5473,
	5474,
	573
	},
	sections = {	-- секции объектов
		"volna_shron",
		"taynik_kuznec7",
		"dyak_mines_box",
		"radiodetail_box2",
		"radiodetail_box4",
		"keis_key_box",
		"computer_flash",
		"notebook_flash",
		"disk_flash",
		"pda_flash",
		"taynik_podarok"
	}
}

local smart_filters = {
	"esc_bridge", "esc_blokpost"
}


local rel_enemy,rel_friend

local look_radius = 60			-- Радиус "обзора"
local look_radius_box = 50		-- Радиус поиска нычек

local search_intensivity = 60	--интенсивность поиска (количество отрабатываемых неписей)

local max_rounds = 10			-- продолжительность боев

local health_wound = 0.20		-- При каком уровне здоровья НПС считается раненым
local health_wound_set = 0.02

local base_fp = 1400			-- Эталон firepower\distance при distance = 1 который снимет 100% health

local dist_coeff = 8			-- Коэффициент для расстояния

local sell_limit = 5000			-- Вещи дешевле продает торговцам, дороже - через новости

local rate_kill_base = 100		-- Рейтинг за убийство. При убийстве более слабого - 0.5 * rate_kill_base, более сильного - 2 * rate_kill_base
local rate_art_found = 100		-- Рейтинг за артефакты

local to_actor = 150			-- расстояние до актёра, на котором работает оффлайн-алайф

function init()
	build_tables()
	iTime = (amk.game_minutes() - iFreq) + 3
	off_npcs={}
end

function update()
	if (bFlag == false and iTime ~= -1) then
		if (amk.game_minutes() - iTime > iFreq) then
			bFlag = true			
			off_npcs={}	
			items={}
			iCounter = 1
		--	amk.mylog("Updating offline-ALife started")
		end
	end
	if (bFlag == true) then
		if (iCounter >= 65535) then
			bFlag = false
			iTime = amk.game_minutes()
			iCounter = 1
		--	amk.mylog("Updating offline-ALife finished")
		else
			add_fresh_meat( AI:object(iCounter) )
			iCounter = iCounter + 1
		end
	end
end

--on_death - не убиваем! off_npcs
--on_hit - не обрабатываем!
function add_fresh_meat(obj)
	if obj and obj.m_game_vertex_id and GGraph:valid_vertex_id(obj.m_game_vertex_id)
		and ( not protected_items.actor_items_keep(obj:section_name()) )
		and ( not protected_items.is_no_offline_alife_npc(obj) )
	then
		local map = object_level_name(obj)
		local cls = obj:clsid()
		if not off_npcs[map] then off_npcs[map]={monsters={},stalkers={},weapons={},artefacts={},inv_boxes={}} end
		if IAmAMonster[cls] and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id == 4294967296 then
				local flags = get_flags(obj.id)
				if bit_and(flags, 1) ~= 1 then --Уберем тех, у кого on_hit есть.
					table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
				end
		elseif cls==clsid.script_stalker and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id == 4294967296 then
				local flags = get_flags(obj.id)
				if bit_and(flags, 1) ~= 1 then --Уберем тех, у кого on_hit есть.
					if obj:community()~="zombied" then
						table.insert(off_npcs[map].stalkers, {id = obj.id, name = obj:name()})
					else
						table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
					end
				end
		elseif IAmAWeapon[cls] then
			if obj.m_story_id == 4294967296 then
				if obj.parent_id then
					local p_obj = AI:object(obj.parent_id)
					if p_obj then
						if p_obj.m_game_vertex_id and GGraph:valid_vertex_id(p_obj.m_game_vertex_id) then
							if p_cls == clsid.inventory_box then
								-- НПС "не видят" этого
								map = ""
							else
								local p_map = object_level_name(p_obj)
								if p_map ~= map then
									if not off_npcs[p_map] then
										off_npcs[p_map] = {	monsters={},stalkers={},weapons={},artefacts={},inv_boxes={} }
									end
									map = p_map
								end	
							end
						end
					end
				end
				if map ~= "" then
					table.insert(off_npcs[map].weapons, {id=obj.id, name = obj:name()}) 
				end
			end
		elseif string_find(obj:section_name(),"^af_") then
			if obj.parent_id then
				local p_obj = AI:object(obj.parent_id)
				if p_obj then
					if p_obj.m_game_vertex_id and GGraph:valid_vertex_id(p_obj.m_game_vertex_id) then
						if p_cls == clsid.inventory_box then
							-- НПС "не видят" этого
							map = ""
						else
							local p_map = object_level_name(p_obj)
							if p_map ~= map then
								if not off_npcs[p_map] then off_npcs[p_map]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}} end
								map = p_map
							end	
						end
					end
				end
			end
			if map ~= "" then table.insert(off_npcs[map].artefacts, {id = obj.id, name = obj:name()}) end
		elseif cls == clsid.inventory_box and not box_is_protected(obj) then
			table.insert(off_npcs[map].inv_boxes, {id = obj.id, name = obj:name()})
		end
			
		if obj.parent_id and obj.m_story_id == 4294967296
			and not (IAmAMonster[cls] or IAmAStalker[cls])
		then
			local zz = AI:object(obj.parent_id)
			if zz then
				if not items[obj.parent_id] then items[obj.parent_id] = {} end
				table.insert(items[obj.parent_id], {id = obj.id, name=obj:name()})
				gps_habar.insert_item(obj.parent_id, obj) -- Idler++-- корректируем хабар в помеченных тайниках
			end
		end
	end
end

--строим таблицу неписей, монстров и оружия
function build_tables()
	rel_enemy = sys_ini:r_float("game_relations", "goodwill_enemy")
	rel_friend = sys_ini:r_float("game_relations", "goodwill_friend")

	--' Предметы, которые нельзя продавать (квестовые например)
	-- уже было загружено в death_manager, возьмём оттуда
	no_sell_table = death_manager.get_keep_items()
	-- Добавим в таблицу, что нельзя продавать.
	local sini = ini_file("misc\\trade_generic.ltx")
	local cfg_sell = sini:r_string("trader", "sell_condition")
	if sini and sini:section_exist(cfg_sell) then
		local result, id, value
		for a = 0, sini:line_count(cfg_sell)-1 do
			result, id, value = sini:r_line(cfg_sell,a,"","")
			if id and (value==nil or value=="") then
				no_sell_table[id] = true
			end
		end
	end
end

function update_trade()
	local obj
	for a=1,65534 do
		obj = AI:object(a)
		if obj then
			process_trade(obj)
		end
	end
end

function update_tables(level)
	off_npcs[level]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}}
	local obj, p_obj
	for a=1,65534 do
		obj = AI:object(a)
		if obj then
			if GGraph:valid_vertex_id(obj.m_game_vertex_id) and object_level_name(obj) == level then
				add_fresh_meat(obj)
			elseif obj.parent_id then
				p_obj = AI:object(obj.parent_id)
				if p_obj and GGraph:valid_vertex_id(p_obj.m_game_vertex_id)	and object_level_name(p_obj) == level then
					add_fresh_meat(obj)
				end
			end
		end
	end	
end

--генерируем оффлайн события
function offline_alife()
	amk.oau_reason="cn offline_alife start"
	local lname = table.random(maps)
--	update_tables(lname)
--	log("# Offline_alife -> %s", lname)
	amk.oau_reason="cn offline_alife chp1"

	local st = 0
	local npcs = off_npcs[lname]
	if npcs then st = #npcs.stalkers end
	if st == 0 then return end

--	log("stalkers found [%s]", st)
	amk.oau_reason="cn offline_alife chp2"
	local idxs = {}
	for i = 1, st do
		table.insert(idxs, i)
	end
	local rnd, idx = 0, 0
	for search = 1, math.min(st, search_intensivity) do
		amk.oau_reason="cn offline_alife chp3"
		idx = math_random(#idxs)
		rnd = idxs[idx]
		table.remove(idxs, idx)
		amk.oau_reason="cn offline_alife chp4"
		if npcs.stalkers[rnd] then 
			amk.oau_reason="cn offline_alife chp5"
			local victim = AI:object(npcs.stalkers[rnd].id)
			amk.oau_reason="cn offline_alife chp6"
			local victim_name = victim and victim:name()
			if victim and (not victim.online) and victim.health and victim.can_switch_online
				and victim:health()>0 and victim:can_switch_online()
				and victim_name == npcs.stalkers[rnd].name
			then
			--	log("- process offline_alife for [%s]", victim_name)
				amk.oau_reason="cn offline_alife chp7 "..victim_name
				local vdata = collect_info(victim,lname)
				amk.oau_reason="cn offline_alife chp8 "..victim_name
			--	table.print(vdata)
				if #vdata.enemies>0 then
					--есть вражина - воюем нах!
					amk.oau_reason="cn offline_alife chp9 "..victim_name
					on_enemies_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.monsters>0 then
					--есть монстрятина - видели, слышали, убили, сдохли...
					amk.oau_reason="cn offline_alife chp10 "..victim_name
					on_monsters_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.corpses.stalkers>0 then
					--есть труп сталкера
					amk.oau_reason="cn offline_alife chp11 "..victim_name
					on_npc_corpses_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.corpses.monsters>0 then
					--есть труп монстра
					amk.oau_reason="cn offline_alife chp12 "..victim_name
					on_monster_corpses_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.weapons.seen>0 then
					--есть бесхозное оружие
					amk.oau_reason="cn offline_alife chp13 "..victim_name
					on_weapons_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.artefacts>0 then
					--есть арты
					amk.oau_reason="cn offline_alife chp14 "..victim_name
					on_artifacts_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.inv_boxes>0 then
					--есть контейнеры. Надо обыскать.
					amk.oau_reason="cn offline_alife chp18 "..victim_name
					on_inv_boxes_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif items[victim.id] and #items[victim.id] > 0 then
					--попробуем продать всякого
					amk.oau_reason="cn offline_alife chp15 "..victim_name
					-- amk.mylog("Offline: lets trade")
					--amk.oau_reason="cn offline_alife chp17 "..victim_name
					process_trade(victim)
					-- amk.mylog("Offline: trade done")
					break
				else
					--amk.mylog("__")
				end
			end
		end
	end
	amk.oau_reason="cn offline_alife end"
end

--собираем инфу о неписе
function collect_info(victim,map)
	local vdata = {}
	vdata.rank = victim:rank() --ранг
	vdata.health = victim:health()  --хелсы
	vdata.community = victim:community()  --группировка

	--пытаемся определить пушку
	local wp = #off_npcs[map].weapons
	--условная огневая мощь
	vdata.fire_power = 0

	vdata.weapons={own={},seen={}}
	-- если есть пушки в карманах, выбираем лучшую (по условной мощности)
	if wp>0 then
		for w=1,wp do
			if off_npcs[map].weapons[w] then
				local www = AI:object(off_npcs[map].weapons[w].id)
				if www and www:name()==off_npcs[map].weapons[w].name then
					if www.parent_id == victim.id then
						table.insert(vdata.weapons.own, {id = www.id, name = www:name()})
						local fp = get_weapon_firepower(www)
						if vdata.fire_power<fp then vdata.fire_power=fp end
					elseif www:can_switch_online()
						and victim.position:distance_to(www.position)<look_radius
						and sobj_is_far(www, to_actor)
					then
						local p_id = www.parent_id
						local p_obj = p_id and AI:object(p_id)
						-- Безхозное оружие
						if p_id==nil or p_id==65535
							-- В нычках без замков можно что-нибудь стырить
							or ( p_obj and p_obj:clsid() == clsid.inventory_box
							and box_is_protected(p_obj)==false
							and victim.position:distance_to(p_obj.position) < look_radius_box )
						then
							table.insert(vdata.weapons.seen, {id = www.id, name = www:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем списки друзей и врагов в зоне "видимости"
	-- Для тех, у кого смарт в фильтрах - не собираем врагов
	-- Для остальных - не учитываем врагов из смартов
	local npc_peaceful = npc_smart_is_peaceful(victim)
	
	vdata.friends={}
	vdata.enemies={}
	vdata.corpses={monsters={},stalkers={}}
	if #off_npcs[map].stalkers>0 then
		for a=1,#off_npcs[map].stalkers do
			if off_npcs[map].stalkers[a] then
				local opponent = AI:object(off_npcs[map].stalkers[a].id)
				if opponent
					and opponent.id~=victim.id
					and opponent.health
					and opponent.can_switch_online
					and opponent:can_switch_online()
					and opponent:name() == off_npcs[map].stalkers[a].name
				then
					if victim.position:distance_to(opponent.position)<look_radius then
						if opponent:health()>0 then
							local rel = relation_registry.get_goodwill(victim.id, opponent.id)
							if rel>=rel_friend then
								table.insert(vdata.friends, {id = opponent.id, name = opponent:name()})
							elseif rel<=rel_enemy then
								if npc_peaceful == false and npc_smart_is_peaceful(opponent) == false then
									table.insert(vdata.enemies, {id = opponent.id, name = opponent:name()})
								end
							end
						else
							if (sobj_is_far(opponent, to_actor)) then
								table.insert(vdata.corpses.stalkers, {id = opponent.id, name = opponent:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список монстряков в зоне "видимости"
	vdata.monsters={}
	if off_npcs[map].monsters then
		if #off_npcs[map].monsters>0 then
			for a=1,#off_npcs[map].monsters do
				if off_npcs[map].monsters[a] then
					local monster = AI:object(off_npcs[map].monsters[a].id)
					if monster
						and monster.health
						and monster.can_switch_online
						and monster:can_switch_online()
						and monster:name() == off_npcs[map].monsters[a].name
						and victim.position:distance_to(monster.position)<look_radius
					then
						if monster:health()>0 then
							table.insert(vdata.monsters, {id = monster.id, name = monster:name()})
						else
							if (sobj_is_far(monster, to_actor)) then
								table.insert(vdata.corpses.monsters, {id = monster.id, name = monster:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список артов в зоне "видимости"
	vdata.artefacts={}
	if off_npcs[map].artefacts then
		if #off_npcs[map].artefacts>0 then
			for a=1,#off_npcs[map].artefacts do
				if off_npcs[map].artefacts[a] then
					local artefact = AI:object(off_npcs[map].artefacts[a].id)
					if (artefact
						and artefact.can_switch_online
						and artefact:can_switch_online()
						and artefact:name() == off_npcs[map].artefacts[a].name
						and victim.position:distance_to(artefact.position)<look_radius
						and sobj_is_far(artefact, to_actor))
					then
						local parent_id = artefact.parent_id
						local parent_obj = (parent_id and parent_id~=65535) and AI:object(parent_id)
						if parent_obj == nil
								or ( ( parent_obj:clsid() == clsid.inventory_box
								and box_is_protected(parent_obj) )
								or IsAnomaly(parent_obj) )
						then
							table.insert(vdata.artefacts, {id = artefact.id, name = artefact:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем список контейнеров в зоне "видимости"
	vdata.inv_boxes={}
	if off_npcs[map].inv_boxes then
		if #off_npcs[map].inv_boxes>0 then
			for a=1,#off_npcs[map].inv_boxes do
				if off_npcs[map].inv_boxes[a] then
					local inv_box = AI:object(off_npcs[map].inv_boxes[a].id)
					if ( inv_box
						and inv_box.can_switch_online
						and inv_box:can_switch_online()
						and inv_box:name() == off_npcs[map].inv_boxes[a].name
						and victim.position:distance_to(inv_box.position)<=look_radius_box
						and sobj_is_far(inv_box, to_actor) )
					then
						local zdist = victim.position:distance_to(inv_box.position)/100
						if math_random() > zdist then
							if inv_box.parent_id==nil or inv_box.parent_id==65535 then
								table.insert(vdata.inv_boxes, {id = inv_box.id, name = inv_box:name()})
							end
						end
					end
				end
			end
		end
	end

	return vdata
end

-- Вокруг враги! Что же делать..
function on_enemies_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found enemy ("..#vdata.enemies..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	-- Собираем weapons
	-- Учитываем rank, weapon, distance...
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
	if (vdata.friends and #vdata.friends > 0) then
		for i=1, #vdata.friends do
			v_obj = vdata.friends[i]
			if v_obj then
				obj = AI:object(v_obj.id)
				if (obj and obj:name()==v_obj.name) then
					wpn = get_npc_weapon(obj)
					rank = obj:rank()
					health = obj:health()
					firepower = get_weapon_firepower(wpn)
					player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
					table.insert(team_A, player)
				end
			end
		end
	end
	for i=1, #vdata.enemies do
		v_obj = vdata.enemies[i]
		obj = AI:object(v_obj.id)
		if (obj and obj:name() == v_obj.name) then
			wpn = get_npc_weapon(obj)
			if (wpn == nil) then
				wpn = list_npc_items(obj)
			end
			rank = obj:rank()
			health = obj:health()
			firepower = get_weapon_firepower(wpn)
			player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
			table.insert(team_B, player)
		end
	end
	local distances = {}
	for a=1, #team_A do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, #team_B do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math_floor(from.position:distance_to(to.position))
				local fp_A = math_floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math_floor(team_B[b].firepower / (dist / dist_coeff))
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	-- Берем тех, у кого самый высокий rank и мин. distance
	table_sort(team_A, function(a,b) return a.rank > b.rank end)
	table_sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = #team_A
	local size_B = #team_B
	local died_A = 0
	local died_B = 0
	for i=1, max_rounds do
		if (#team_A >0 and #team_B > 0) then
			local index = #team_A
			local attacker
			local defender 
			local attack_info 
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance			
			if (#team_B > index) then index = #team_B end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math_random(#team_B)]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					--amk.mylog(attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					-- master to novice - 30% max
					-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
					rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
					distance_hit_chance = 100 - math_floor((attack_info.distance) / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math_random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if (attack_info.fp >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp)
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if bit_and(defender.flags, 2) == 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))
									end
								end
								-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and #items[defender.player.id] > 0) then
									-- amk.mylog("В трупе "..defender.player:name().." "..#items[defender.player.id].." вещичек.")
									for a=1,#items[defender.player.id] do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = AI:object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													-- amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end
											end	
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						--amk.mylog(attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						--amk.mylog(attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math_random(#team_A)]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						--amk.mylog(attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Попал или нет? Зависит от: расстояния, рангов
						-- master to novice - 30% max
						-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
						rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
						distance_hit_chance = 100 - math_floor((attack_info.distance) / 1.5)					
						hit_chance = distance_hit_chance + rank_hit_chance
						if math_random() * 100 < hit_chance then
							-- Попал таки, гад. Посмотрим, как сильно.
							if attack_info.fp >= base_fp then
								-- Все, убил.
								defender.health = 0
							else
								defender.health = defender.health - (attack_info.fp / base_fp)
								if (defender.health < 0 ) then defender.health = 0 end
							end
							if (defender.health <= 0) then
								if bit_and(defender.flags, 2) == 2 then
									defender.health = health_wound
								else								
									-- Если сталкер - дадим опыт.
									if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
										local m_comm  = attacker.player:community()
										if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
											-- Будет теперь опытным.
											local coeff = 1
											if (defender.rank < attacker.rank) then coeff = 0.5 end
											if (defender.rank > attacker.rank) then coeff = 2 end
											attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))							
										end
									end
									-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
									news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
									-- Заберем вещички с трупа
									local itB, v_itB
									local l_objB
									if (items[defender.player.id] and #items[defender.player.id] > 0) then
										-- amk.mylog("В трупе "..defender.player:name().." "..#items[defender.player.id].." вещичек.")
										for a=1,#items[defender.player.id] do
											v_itB = items[defender.player.id][a]
											if (v_itB) then
												itB = AI:object(v_itB.id)
												if (itB and itB:name() == v_itB.name and itB.parent_id == defender.player.id) then
													l_objB = pick_item(attacker.player, itB)
												else
													if(itB) then
														local mm = itB.parent_id
														if mm == nil then mm = "nil" end
														-- amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itB:name().." parent_id="..mm)													
													end
												end
											end
										end
									end
									process_trade(attacker.player)
								end
							end
							--amk.mylog(attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
						else
							--amk.mylog(attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				-- amk.mylog("Участник команды А погиб. "..vv.player:name())			
				set_npc_health(vv.player, 0)
				table_remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды А ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_A, kk)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				-- amk.mylog("Участник команды B погиб. "..vv.player:name())
				set_npc_health(vv.player, 0)
				table_remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды B ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_B, kk)
			end
		end		
	end
	-- amk.mylog("Бой закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- Вокруг монстры! Что же делать..
function on_monsters_found(victim, vdata)
--	local rsn = "on_monsters_found ["..victim:name().."] "
 -- amk.oau_reason=rsn.."begin"
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found monsters ("..#vdata.monsters..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
		--amk.add_spot_on_map(victim.id,"red_location", s)
	end
	-- Собираем комманды.
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
 -- amk.oau_reason=rsn.."chp1"
	if (vdata.friends and #vdata.friends > 0) then
		for i=1, #vdata.friends do
			v_obj = vdata.friends[i]
			obj = AI:object(v_obj.id)
			if (obj and obj:name()==v_obj.name) then
				wpn = get_npc_weapon(obj)
				rank = obj:rank()
				health = obj:health()
				firepower = get_weapon_firepower(wpn)
				player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
				table.insert(team_A, player)
			end
		end
	end
  --amk.oau_reason=rsn.."chp2"
	local params
	for i=1, #vdata.monsters do
  --amk.oau_reason=rsn.."chp2.1"
		v_obj = vdata.monsters[i]
		obj = AI:object(v_obj.id)
  --amk.oau_reason=rsn.."chp2.2"
		if (obj and obj:name() == v_obj.name) then
  --amk.oau_reason=rsn.."chp2.3 "..v_obj.name
			params = get_monster_params(obj)
  --amk.oau_reason=rsn.."chp2.4"
			if (params) then
  --amk.oau_reason=rsn.."chp2.5"
				rank = obj:rank()
  --amk.oau_reason=rsn.."chp2.6"
				health = obj:health()
  --amk.oau_reason=rsn.."chp2.7"
				firepower = params.attack * base_fp
  --amk.oau_reason=rsn.."chp2.8"
				player = {player = obj, speed = params.speed, attack_dist = params.dist, immunity = params.immunity, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id) }
  --amk.oau_reason=rsn.."chp2.9"
				table.insert(team_B, player)
  --amk.oau_reason=rsn.."chp2.10"
			else
  --amk.oau_reason=rsn.."chp2.11"
				-- amk.mylog("get_monster_params returns nil for "..obj:name())
  --amk.oau_reason=rsn.."chp2.12"
		end
	end
	end
  --amk.oau_reason=rsn.."chp3"
	local distances = {}
	for a=1, #team_A do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, #team_B do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math_floor(from.position:distance_to(to.position))
				local fp_A = math_floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math_floor(team_B[b].firepower)
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
  --amk.oau_reason=rsn.."chp4"
	-- Берем тех, у кого самый высокий rank и мин. distance
	table_sort(team_A, function(a,b) return a.rank > b.rank end)
	table_sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = #team_A
	local size_B = #team_B
	local died_A = 0
	local died_B = 0
  --amk.oau_reason=rsn.."chp5"
	for i=1, max_rounds do
		if (#team_A >0 and #team_B > 0) then
			local index = #team_A
			local attacker
			local defender
			local attack_info
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance
			if (#team_B > index) then index = #team_B end
  --amk.oau_reason=rsn.."chp5.1 : "..i
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math_random(#team_B)]
  --amk.oau_reason=rsn.."chp5.2 : "..i..":"..j
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					-- amk.mylog(attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
					local dii = math_floor(attack_info.distance - defender.speed * i * 5)
					if (dii <=8) then dii = 45 end -- Вблизи еще и фиг попадешь...
					distance_hit_chance = 100 - math_floor(dii / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math_random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
 --amk.oau_reason=rsn.."chp5.3 : "..i..":"..j
						if ( math_floor(attack_info.fp * defender.immunity) >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp) * defender.immunity
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if bit_and(defender.flags, 2) == 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))
									end
								end
  --amk.oau_reason=rsn.."chp5.4.0"
								-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
  --amk.oau_reason=rsn.."chp5.4 : "..i..":"..j
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and #items[defender.player.id] > 0) then
									-- amk.mylog("В трупе "..defender.player:name().." "..#items[defender.player.id].." вещичек.")
									for a=1,#items[defender.player.id] do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = AI:object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													-- amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end											
											end			
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						--amk.mylog(attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						--amk.mylog(attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
  --amk.oau_reason=rsn.."chp5.5 : "..i
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math_random(#team_A)]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						-- amk.mylog(attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Для начала неплохо бы узнать, добежал ли монстрик до дистанции атаки.
						if (attack_info.distance - attacker.speed * i * 5 < attacker.attack_dist) then
							rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
							distance_hit_chance = 100
							hit_chance = distance_hit_chance + rank_hit_chance
							if math_random() * 100 < hit_chance then
								-- Попал таки, гад. Посмотрим, как сильно.
								if attack_info.fp >= base_fp then
									-- Все, убил.
									defender.health = 0
								else
									defender.health = defender.health - (attack_info.fp / base_fp)
									if (defender.health < 0 ) then defender.health = 0 end
								end
								if (defender.health == 0) then
									if bit_and(defender.flags, 2) == 2 then
										defender.health = health_wound
									else
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", nil")
										news_main.on_offline_death(defender.player, attacker.player, nil)
										-- Забитрать вещички с трупа не будем. Хотя, может некоторые клептоманы...
										-- А вот труп грохнуть... Надо подумать :)
									end
								end
								--amk.mylog(attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
							else
								--amk.mylog(attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
							end
						else
							-- amk.mylog(attacker.player:name().." [team_B] еще не добежал "..(attack_info.distance - attacker.speed * i * 5).." метров до "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
 --amk.oau_reason=rsn.."chp5.6 : "..i
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				-- amk.mylog("Участник команды А погиб. "..vv.player:name())			
				set_npc_health(vv.player, 0)
				table_remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды А ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_A, kk)
			end
		end
 --amk.oau_reason=rsn.."chp5.7 : "..i
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				-- amk.mylog("Участник команды B погиб. "..vv.player:name())
				set_npc_health(vv.player, 0)
				table_remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды B ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_B, kk)
			end
		end		
	end	
  --amk.oau_reason=rsn.."end"
	-- amk.mylog("Бой с монстрами закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- О, трупик. Щас шмонать будем.
function on_npc_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.stalkers == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found stalker's corpse ("..#vdata.corpses.stalkers..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local id
	local v_id = victim.id
	for i=1, #vdata.corpses.stalkers do
		v_obj = vdata.corpses.stalkers[i]
		local corpse = AI:object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)
			id = corpse.id
			if (id and items[id]) then
				for a=1, #items[id] do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = AI:object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, трупик монстра. Будем шмонать?
function on_monster_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.monsters == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found monster's corpse ("..#vdata.corpses.monsters..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local object
	local id
	local v_id = victim.id
	for i=1, #vdata.corpses.monsters do
		v_obj = vdata.corpses.monsters[i]
		local corpse = AI:object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)		
			id = corpse.id
			if (id and items[id]) then
				for a=1, #items[id] do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = AI:object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- Хорошая пушка - не помешает.
function on_weapons_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found weapons ("..#vdata.weapons.seen..") for "..victim.id.." on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local object
	local v_id = victim.id
	for i=1, #vdata.weapons.seen do
		v_obj = vdata.weapons.seen[i]
		if (v_obj) then
			object = AI:object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
			end
		end
	end
	process_trade(victim)
end

-- Моя прелесссть
function on_artifacts_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if victim and IAmAStalker[victim:clsid()] and victim.community then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, #vdata.artefacts do
		v_obj = vdata.artefacts[i]
		if (v_obj) then
			object = AI:object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
				if (obj) then
					if (b_stalker == true) then
						victim:set_rank(victim:rank() + rate_art_found)
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, нычка - это гуд.
-- Idler ++
-- проверим, а сможет ли непись долезть до  тайника.
-- если есть аномалии в радиусе 20м, меньше шансов или если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail(victim, box)
	if (victim == nil or box == nil or box.id == 0) then return false end

	-- отсекаем сюжетные тайники
	if box_is_protected(box) then return false end

	local n_rnd
	if victim.position and box.position then 
		n_rnd = math_random(2, 5)
		--get_console():execute("load ~~~ Непись пробует добраться до тайника " .. tostring(box.id) .. ". npc.y = " .. tostring(victim.position.y) .. " box.y = " .. tostring(box.position.y) .. " rnd = " .. tostring(n_rnd))
		if math_abs(box.position.y - victim.position.y) > n_rnd then
			--get_console():execute("load ~~~ Не добрался. Высоко")
			return false
		end 
	end

	local anom_list=amk_anoms.get_anomaly_list_for_pos(box.position,20) 
	local n_anoms = #anom_list
	n_rnd = math_random(1, 100)
	--get_console():execute("load ~~~ Непись пробует добраться до тайника " .. tostring(box.id) .. ". Рядом " .. tostring(n_anoms) .. " аномалий. " .. tostring(n_rnd))
	if n_rnd < n_anoms * 20 then -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При 5 - точно до ящика не доберется
		--get_console():execute("load ~~~ Не решился лезть в аномалии.")
		return false
	end
	
	
	--get_console():execute("load ~~~ Долез настырный")
	return true
end
-- Idler --

function on_inv_boxes_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if victim and IAmAStalker[victim:clsid()] and victim.community then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, #vdata.inv_boxes do
		v_obj = vdata.inv_boxes[i]
		if (v_obj) then
			object = AI:object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				if inv_box_is_avail(victim, object) then  -- Idler ++-- если нычка доступна - можно шмонать
					if items[v_obj.id] and #items[v_obj.id]>0 then
						for a=1,#items[v_obj.id] do
							local v_itA = items[v_obj.id][a]
							if (v_itA) then
								local itA = AI:object(v_itA.id)
								if (itA and itA:name()==v_itA.name and itA.parent_id == v_obj.id) then
									--news_main.trace("on_inv_boxes_found - found "..itA:section_name().." in "..object:name())
									-- Решим, подбираем или нет?
									if is_valuable(itA) then
										local l_objA = pick_item(victim, itA)
									end
								else
									if(itA) then
										local mm = itA.parent_id
										if mm == nil then mm = "nil" end
										-- amk.mylog("В контейнере "..object:name().." странная вещичка - "..itA:name().." parent_id="..mm)
									end											
								end			
							end
						end
					else
						invbox_new.offline_npc_found_box(victim, v_obj)
					end
				end
			end
		end
		if (b_stalker == true) then
			victim:set_rank(victim:rank() + rate_art_found)
		end
	end
	process_trade(victim)
end

function pick_fake_item(npc, sect)
	local new = AI:create(sect, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
	if new and new.parent_id then
		if not items[new.parent_id] then items[new.parent_id] = {} end
		table.insert(items[new.parent_id], {id = new.id, name = new:name()})
	end
	return new
end

function pick_item(npc, obj)
	local new = nil
	if (npc and obj and Actor and obj.id ~= Actor:id()) then
		local section = obj:section_name()
		new = AI:create(section, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
		if (new) then
			if (new.parent_id) then
				if not items[new.parent_id] then items[new.parent_id] = {} end
				table.insert(items[new.parent_id], {id = new.id, name = new:name()})
				gps_habar.insert_item(new.parent_id, new) -- Idler++-- корректируем хабар в помеченных тайниках
			end
			if (obj.parent_id and items[obj.parent_id] and #items[obj.parent_id]>0) then
				for z=1, #items[obj.parent_id] do
					if (items[obj.parent_id][z] and items[obj.parent_id][z].id == obj.id) then
						gps_habar.remove_item(obj.parent_id, items[obj.parent_id][z]) -- Idler++-- корректируем хабар в помеченных тайниках
						table_remove(items[obj.parent_id], z)
						break
					end
				end
			end
			AI:release(AI:object(obj.id), true)
		end
	end
	return new
end

function get_npc_weapon(npc)
	local obj = nil
	local fp = 0
	if (npc) then
		if items ~= nil and npc.id ~= nil and items[npc.id] ~= nil then -- заплатка от вылета //[fR4g]
			for k,v in pairs(items[npc.id]) do --- вылет был тут
				local wpn = AI:object(v.id)
				if wpn and IAmAWeapon[wpn:clsid()] and wpn:name() == v.name and wpn.parent_id == npc.id then
					local sect = wpn:section_name()
					local cur_fp = 0				
					local modes = rx_wmgr.read_wm_modes(npc:community(),ranks.get_obj_rank_name(npc),npc:section_name())
					local params = rx_wmgr.read_wpn_params(sect)
					if modes.mode1 == "1" then
						cur_fp = params.cst + modes.addcost
					elseif modes.mode1 == "2" then
						local kf = rx_wmgr.wm_modes.koeffs[modes.koeffs]
						cur_fp = (params.dmg*kf.dmg)+(params.rpm*kf.rpm)+(params.dst*kf.dst)+((100/params.dsp)*kf.dsp)
					elseif modes.mode1 == "3" then
						cur_fp = rx_wmgr.wm_modes.priors[modes.priors][sect] or 0
					end
					if cur_fp > fp then
						fp = cur_fp
						obj = wpn
					end			
				end
			end
		end
	end
	return obj
end

function get_weapon_firepower(wpn)
	if wpn and IAmAWeapon[wpn:clsid()] then
		local sect = wpn:section_name()
		if wpn_fp[sect] then
			return wpn_fp[sect]
		else
			if table.find(xrs_grenade.gr_types, sect) == false then
				local priority = sys_ini:r_u32_ex(sect, "ef_weapon_type", 1)
				local priority2 = sys_ini:r_u32_ex(sect, "ef_main_weapon_type", 0)
				local fd = sys_ini:r_float_ex(sect, "fire_distance", 1)
				local bs = sys_ini:r_float_ex(sect, "bullet_speed", 1)
				local rpm = sys_ini:r_float_ex(sect, "rpm", 1)
				if priority>1 then
					if priority2>0 then
						priority = priority + priority2
					end
				end
				local fp = priority*1000 + math.sqrt(fd*bs*rpm)
				wpn_fp[sect] = fp
				
				return fp
			end
		end
	end
	return 0
end

function get_weapon_cost(weapon)
	if (weapon and IAmAWeapon[weapon:clsid()]) then
		return sys_ini:r_float_ex(weapon:section_name(), "cost", 0)
	end
	return 0
end

function get_item_cost(item)
	if item then
		return sys_ini:r_float_ex(item:section_name(), "cost", 0)
	end
	return 0
end

function set_npc_health(obj, health)
	if (obj and health >=0 and health <=2) then
		if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
			netpk:modify( obj, { health = health, upd = { health = health } } )
		end
		if health == 0 then
			on_death(obj.id)
		end
	end
end

function list_npc_items(obj)
	if (obj) then
		log1("! amk_offline_alife: can't find weapon for "..obj:name()..":")
		local it
		for a=1,65534 do
			it = AI:object(a)
			if (it and it.parent_id == obj.id) then
				log1("~ -> "..it:name().." "..it:section_name())
				if (IAmAWeapon[it:clsid()]) then
					table.insert(items[obj.id], {id = it.id, name = it:name()})
					return it
				end
			end			
		end
	end
end

function dbg_show_team(team)
	if(team) then
		for k, player in pairs(team) do
			if (player.weapon) then
				mylog("Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon="..player.weapon:name().." firepower="..player.firepower)
			else
				mylog("Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon=none firepower="..player.firepower)
			end
		end
	end
end

--[[
	Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.	
	Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
	Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class + item_dependence
	Оставили одно, которое лучше (а), но патронов нет (б) (%)
	Одно, которое лучше (а), но хуже (б) - в новости на продажу
	Остальное на продажу
	Патроны оставили только те, что подходят к (а), остальные на продажу
	Для вояк - только родной калаш надо бы... Не продавать вобще?
	Оставляем не более 2 аптечек и бинтов, антирада
	Оставляем 1-2 гранаты (%)
	Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
	Еда, водка - не более 1-2 шт (%)	
	Броники наверное продаем...
	Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
]]
function process_trade(npc)
	-- Имеет смысл проверять на наличие trade в секции [logic]...
	if npc and IAmAStalker[npc:clsid()] and npc:alive()
		and npc.m_story_id~=nil and npc.m_story_id == 4294967296
		and items[npc.id] and #(items[npc.id])>0
		and not protected_items.is_no_offline_alife_npc(npc)
	then
	--	log1("# process_trade: "..npc:name())
		local item_list = {}
		local sell_list = {}
		local m_comm = npc:community()
		local b_stalker = false		
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom" or m_comm == "nebo" or m_comm == "green") then
			if (npc.name and npc:name() ~= "agr_ratcatcher") then
				b_stalker = true
			end
		elseif m_comm == "zombied" then
			return
		end
			
		--Фильтруем квестовые items - no_sell_table
		local nid = npc.id
		local npc_items = items[nid]
		local obj, sect
		local t_remove = {}
		for ok,ov in ipairs(npc_items) do
			obj = AI:object(ov.id)
			if obj and obj.parent_id == nid then
				if obj and obj:name()==ov.name then
					sect = obj:section_name()
					if protected_items.actor_items_keep(sect)
						or no_sell_table[sect] == true
					then
						-- Это нам не надо.
					else
						table.insert(item_list, obj)
					end
				end
			else
				table.insert(t_remove, ok)
			end
		end
		if #t_remove>0 then
		--	table.print(t_remove)
			for i = #t_remove, 1, -1 do
				table_remove(npc_items, t_remove[i])
			end
		end
	--	log1("item_list")
	--	table.print(item_list)
		if #item_list > 0 then
			table_sort(item_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)		
			-- Выберем, что за оружие оставит себе NPC.
			local cnt_medkit = 0
			local cnt_antirad = 0
			local cnt_bandage = 0
			local cnt_grenade = 0
			local cnt_food = 0
			local cnt_drink = 0
			local cnt_torch = 0
			local cnt_pda = 0
			local cnt_radio = 0
			local cnt_guitar = 0
			local cnt_harmonica = 0
			local cnt_binocular = 0
			local cnt_knife = 0
			local cnt_arts = 0
			local cnt_detector = 0
			local cnt_addons = 0
			local cnt_mparts = 0
			
			local weapons = {}
			local ammoss = {}
			for k,v in pairs(item_list) do			
				local sect = v:section_name()
				local cls = v:clsid()
				if IAmAWeapon[cls] and not (table.find(xrs_grenade.gr_types, sect) or sect == "wpn_knife") then
					local ac = getIniValueString(sect, "ammo_class", "", nil)
					if ac and ac ~= "" then
						table.insert(weapons, { obj = v, ammo = string.explode(ac, ",", true) } )
					else
						table.insert(weapons, {obj = v, ammo = nil})
					end
				elseif isAmmo(nil, cls) then
					if ammoss[sect] == nil then 
						ammoss[sect] = 1
					else
						ammoss[sect] = ammoss[sect] + 1
						if ammoss[sect] > 1 then
							table.insert(sell_list, v)
						end
					end
				elseif string_find(sect, "^af_") then
					-- 3 самых хороших арта оставили себе (+здоровье), остальные на продажу (фильтруем булыжник)				
					if sect ~= "af_buliz" then
						cnt_arts = cnt_arts + 1
						if cnt_arts > 3 then
							table.insert(sell_list, v)
						end	
					else	-- булыжники на продажу без фильтра
						table.insert(sell_list, v)
					end		
				elseif sect == "device_torch" then
					cnt_torch = cnt_torch + 1
					if cnt_torch > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "device_pda" then
					cnt_pda = cnt_pda + 1
					if cnt_pda > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "hand_radio" then
					cnt_radio = cnt_radio + 1
					if cnt_radio > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "harmonica_a" then
					cnt_harmonica = cnt_harmonica + 1
					if cnt_harmonica > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "guitar_a" then
					cnt_guitar = cnt_guitar + 1
					if cnt_guitar > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "binocular_a" or sect == "wpn_binoc" then
					cnt_binocular = cnt_binocular + 1
					if cnt_binocular > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "wpn_knife" then
					cnt_knife = cnt_knife + 1
					if cnt_knife > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "medkit" or sect == "medkit_army" or sect == "medkit_scientic" then
					cnt_medkit = cnt_medkit + 1
					if cnt_medkit > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "antirad" then
					cnt_antirad = cnt_antirad + 1
					if cnt_antirad > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "bandage" then
					cnt_bandage = cnt_bandage + 1
					if cnt_bandage > 3 then
						table.insert(sell_list, v)
					end
				elseif table.find(xrs_grenade.gr_types, sect) then
					cnt_grenade = cnt_grenade + 1
					if cnt_grenade > 2 then
						table.insert(sell_list, v)
					end
				elseif sect == "bread_a" or sect =="bread" or sect == "kolbasa" or sect == "kolbasa_a" or sect == "conserva" then
					cnt_food = cnt_food + 1
					if cnt_food > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "vodka_a" or sect =="vodka" or sect == "energy_drink" then
					cnt_drink = cnt_drink + 1
					if cnt_drink > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "detector_simple" or sect =="detector_advances" or sect == "detector_elite" then
					cnt_detector = cnt_detector + 1
					if cnt_detector > 1 then
						table.insert(sell_list, v)
					end
				elseif rx_addons and rx_addons.item_is_addon(v, cls) then
					cnt_addons = cnt_addons + 1
					if cnt_addons > 2 then
						table.insert(sell_list, v)
					end
				elseif sys_ini:line_exist(sect, "monster_part") then
					cnt_mparts = cnt_mparts + 1
					if cnt_mparts > 2 then
						table.insert(sell_list, v)
					end
				else
					--news_main.trace("Process trade - unknown - "..sect.." "..v:name())
				end			
			end
		--	log("~ amk_offline_alife.process_trade '%s'", npc:name())

		--	log("\nweapons:")
		--	table.print(weapons)
			local modes = rx_wmgr.read_wm_modes(npc:community(),ranks.get_obj_rank_name(npc),npc:section_name())
			local weapons_types = {}
			for z,i in ipairs(modes.types) do
				weapons_types[i.t] = {}
			end
			for i,w in ipairs(weapons) do
				local sect = w.obj:section_name()				
				local params = rx_wmgr.read_wpn_params(sect)
				local prm = 0
				if modes.mode1 == "1" then
					prm = params.cst + modes.addcost
				elseif modes.mode1 == "2" then
					local kf = rx_wmgr.wm_modes.koeffs[modes.koeffs]
					prm = (params.dmg*kf.dmg)+(params.rpm*kf.rpm)+(params.dst*kf.dst)+((100/params.dsp)*kf.dsp)
				elseif modes.mode1 == "3" then
					prm = rx_wmgr.wm_modes.priors[modes.priors][sect] or 0
				end
				for k,v in ipairs(modes.types) do
					if v.t == params.typ then
						prm = prm + prm*v.p/100
						break
					end
				end
				if weapons_types[params.typ] then
					table.insert(weapons_types[params.typ],{obj = w.obj,ammo = w.ammo,prm = prm})
				end
			end
		--	log("\ncheck weapon types:")
		--	table.print(weapons_types)
			-- Так, теперь у нас отсортированны все пушки НПС. Найдем ту, для которой есть патроны...
			local wpn_cnt = 2	-- максимальное количество оружия, которое оставим нпс
		--	local npc_wpns = {}
			for k,v in pairs(weapons_types) do
				table_sort(v,function(a,b) return a.prm > b.prm end)
			--	log("sort types: %s", k)
			--	table.print(v)
				local b_best = false
				for i,w in ipairs(v) do
					-- Будем выбирать по одному лучшему стволу каждого типа (они в начале таблицы)
					if b_best == false and wpn_cnt > 0 then
						local b_ammo = false
						local vac = w.ammo
						if vac and #vac>0 then
							for kk, vv in pairs(vac) do
								if ammoss[vv] and ammoss[vv] > 0 then -- Так, патроны есть.
									b_ammo = true
									break
								end
							end
						end
						--	log1("* best weapon: "..w.obj:name())
						-- Нет патронов, надо доспавнить
						if b_ammo == false and vac and vac[1] then
							local o = AI:create(vac[1], npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, nid)
							if o then
								table.insert(npc_items, {id = o.id, name = o:name()})
							--	log("* spawn ammo: %s", o:section_name())
							end
						end
						wpn_cnt = wpn_cnt - 1
						b_best = true
					--	table.insert(npc_wpns, w.obj)
					else
						table.insert(sell_list, w.obj)
					end
				end
			end

			-- Так, с оружием закончили...
			-- Все, что осталось - надо продать.
			-- 1 самое дорогое можно попробовать через новости...
			item_list = nil
			local money = 0
		--	log1("sell_list:")
		--	table.print(sell_list)
			if #sell_list>0 then
			--	log("~ amk_offline_alife: npc %s can trade", npc:name())
				table_sort(sell_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)
			--	table.print(sell_list)
			--	log("\n has weapons:")
			--	table.print(npc_wpns)
				local zz = sell_list[1]
				if zz and b_stalker == true and (get_item_cost(zz) >= sell_limit) then
					-- Продадим через новости.
				--	log("~ news_main.on_offline_trade: %s -> %s", npc:name(), zz:name())
					news_main.on_offline_trade(npc, zz)
					table_remove(sell_list, 1)
				end
			end
			for kk,vv in pairs(sell_list) do
				local cost = get_item_cost(vv)
				if (cost > 0) then
					local coeff = math_random(30,50) / 100
					local price = math_floor(cost * coeff)
					money = money + price
					-- Почистим items
					if #npc_items>0 then
						for z=1, #npc_items do
							if npc_items[z].id == vv.id then
								gps_habar.remove_item(nid, npc_items[z]) -- Idler++-- корректируем хабар в помеченных тайниках
								table_remove(npc_items, z)
								break
							end
						end
					end
				--	log("* sell [%s]", vv:name())
					AI:release(vv, true)
				end				
			end
			if (money > 0) then
				local tbl = netpk:get( npc, netpk.fState )
				tbl.money = tbl.money + money
				netpk:set( npc, tbl )
			--	log("- give money %d \n", money)
			end
		end
	end
end

-- Строим таблицы, если надо.
-- В них - макс. скорость, сила атаки, дистанция атаки.
-- Не забываем про иммунитеты.
-- Поучаем immunities_sect
-- В immunities_sect читаем fire_wound_immunity. Все повреждения множим на него.
function get_monster_params(obj)
 -- amk.oau_reason="get_monster_params chp1"
  local sect = obj:section_name()
	if (obj and IAmAMonster[obj:clsid()]) or (obj and obj.community and obj:community()=="zombied") then
 -- amk.oau_reason="get_monster_params chp2"
		if (monster_params and monster_params[sect]) then
 -- amk.oau_reason="get_monster_params chp3"
			return monster_params[sect]
		else
 -- amk.oau_reason="get_monster_params chp4"
			-- local speed 	= utils.cfg_get_number(sys_ini, obj:section_name(), "MaxSpeed", obj, false, 5)
			local speed 	= sys_ini:r_float_ex(sect, "MaxSpeed", 5)
 -- amk.oau_reason="get_monster_params chp5"
			-- local dist 	= utils.cfg_get_number(sys_ini, obj:section_name(), "MaxAttackDist", obj, false, 3)
			local dist 		= sys_ini:r_float_ex(sect, "MaxAttackDist", 3)
 -- amk.oau_reason="get_monster_params chp6"
			-- local imm_sect = utils.cfg_get_string(sys_ini, obj:section_name(), "immunities_sect", obj, false, "", "")
			local imm_sect 	= sys_ini:r_string_ex(sect, "immunities_sect", "")
 -- amk.oau_reason="get_monster_params chp7"
			-- local immunity 	= utils.cfg_get_number(sys_ini, imm_sect, "fire_wound_immunity", obj, false, 1)
			local immunity 	= sys_ini:r_float_ex(imm_sect, "fire_wound_immunity", 1)
 -- amk.oau_reason="get_monster_params chp8"
			-- local att_sect 	= utils.cfg_get_string(sys_ini, obj:section_name(), "attack_params", obj, false, "", "")
			local att_sect 	= sys_ini:r_string_ex(sect, "attack_params", "")
 -- amk.oau_reason="get_monster_params chp9"
			local attack	= 0
 -- amk.oau_reason="get_monster_params chp10 "..tostring(att_sect)
			if (sys_ini:section_exist(att_sect)) then
 -- amk.oau_reason="get_monster_params chp11"
				local result, id, value = nil, nil, nil
				local max_attack = 0
 -- amk.oau_reason="get_monster_params chp12"
				for a=0, sys_ini:line_count(att_sect)-1 do
 -- amk.oau_reason="get_monster_params chp13"
					result, id, value = sys_ini:r_line(att_sect,a,"","")
 -- amk.oau_reason="get_monster_params chp14"
					if id~=nil and trim(id)~="" and trim(id)~=nil and value~=nil then
 -- amk.oau_reason="get_monster_params chp15"
						local m_value = string.explode(trim(value), ",", true)
 -- amk.oau_reason="get_monster_params chp16"
						if (m_value and #m_value>2) then
 -- amk.oau_reason="get_monster_params chp17"
							local v = tonumber(m_value[2])
 -- amk.oau_reason="get_monster_params chp18"
							if (v and v > max_attack) then					
 -- amk.oau_reason="get_monster_params chp19"
								max_attack = v
							end
						end
					end
				end
 -- amk.oau_reason="get_monster_params chp20"
				attack = max_attack
			end
      -- amk.mylog("speed for "..obj:section_name().." is "..tostring(speed))
			monster_params[sect] = {speed = speed, dist = dist, immunity = immunity, attack = attack}
			return monster_params[sect]			
		end
	else
		return nil
	end
end

function sobj_is_far(obj, distance)
	local result = true
	if (Actor and obj and distance and obj.position ) then
		-- на одном ли уровне?
		if obj.m_game_vertex_id and GGraph:valid_vertex_id(obj.m_game_vertex_id) then
			local map = object_level_name(obj)
			if (map and level.name() == map) then
				-- Достаточно ли далеко?
				if (obj.position:distance_to(Actor:position()) < distance) then
					result = false
				end
			end
	   end
   end
   return result
end

function box_is_protected(v)
	if v then
		-- проверяем по секции объекта
		local chk = v:section_name()
		-- отсекаем сюжетные тайники
		if transparent_treasure.IsTaken(chk) and chk ~= "m_inventory_box" then
			return true
		end

		for k, o in pairs(protected.sections) do
			if o == chk then return true end
		end

		-- проверяем по имени объекта
		chk = v:name()
		for k, o in pairs(protected.names) do
			if o == chk then return true end
		end

		-- проверяем по ID объекта
		chk = v.id
		for k, o in pairs(protected.ids) do
			if o == chk then
				local p = zamok.reliability_code_check( chk ) + 1 /( level.get_game_difficulty()*10 + 5 )
				if math_random() > p then return false
				else return true end
			end
		end

		-- проверяем по story ID объекта
		chk = v.m_story_id
		for k, o in pairs(protected.story_ids) do
			if o == chk then return true end
		end
	end
	return false
end

function npc_smart_is_peaceful(sobj)
	local result = false
	if (sobj and smart_filters and #smart_filters>0) then
		if (sobj.smart_terrain_id and sobj:smart_terrain_id() and sobj:smart_terrain_id()~=65535) then
			local sm = AI:object(sobj:smart_terrain_id())
			if (sm and sm.name and sm:name()) then
				local sn = sm:name()
				for ks, vs in pairs(smart_filters) do
					if (vs == sn) then
						-- Ага, он у нас мирный.
						result = true
						break
					end
				end
			end
		end
	end
	return result
end

function on_death(npc_id)
	smart_terrain.on_death( npc_id )
end

function get_flags(npc_id)
	local flags = 0
	local obj = AI:object(npc_id)
	if obj then
		if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
			local char_ini = xr_logic.get_customdata_or_ini_file(obj, "<customdata>")
			if char_ini:section_exist("logic") then
				if char_ini:line_exist("logic", "on_hit") then
					flags = bit_or(flags, 1)
				end
				if char_ini:line_exist("logic", "on_death") then
					flags = bit_or(flags, 2)
				end
			end
		end
	end
	return flags
end

function is_valuable(item, section)
	if not (item or section) then return false end

	local result = false

	local sect = section or item:section_name()
	local cls = section and sys_ini:r_clsid(section, "class") or item:clsid()

	if (not (IAmAMonster[cls] or IAmAStalker[cls])) and (not protected_items.actor_items_keep(sect)) then
		-- Уники не подбираем (пока?)
		if no_sell_table[sect] == true then
			return false
		end

		local cost = sys_ini:r_float_ex(sect, "cost")
		if IAmAWeapon[cls] and cost >= 1000 then
			result = true
		elseif cost >= 800 then
			result = true
		end
	end
	return result
end
