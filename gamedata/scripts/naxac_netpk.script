-- -*- mode: lua; encoding: windows-1251 -*-

-- Модуль для работы с net_paket'ами объектов, "заточен" под солянку

local torch_flags = {
	Active            = 1,
	NightVisionActive = 2,
	Attached          = 4
}
local addon_flags = {
	scope    = 1,
	launcher = 2,
	silencer = 4
}
local trader_flags = {
	Dummy        = 0,
	InfiniteAmmo = 1
}
local object_flags = {
	UseSwitches       =    1,
	SwitchOnline      =    2,
	SwitchOffline     =    4,
	Interactive       =    8,
	VisibleForAI      =   16,
	UsefulForAI       =   32,
	OfflineNoMove     =   64,
	UsedAI_Locations  =  128,
	UseGroupBehaviour =  256,
	CanSave           =  512,
	VisibleForMap     = 1024,
	UseSmartTerrains  = 2048,
	CheckForSeparator = 4096,
	CorpseRemoval     = 8192
}
local restrictor_type = {
	DefaultRestrictorTypeNone = 0,
	DefaultRestrictorTypeOut  = 1,
	DefaultRestrictorTypeIn   = 2,
	RestrictorTypeNone        = 3,
	RestrictorTypeIn          = 4,
	RestrictorTypeOut         = 5
}
--------------------------------------------------------------------------------------------------
class "n_netpk"

local clsid2func = {}

function n_netpk:__init()
	self.state = false
	self.update = false
end

function n_netpk:__finalize() end

function n_netpk:get( obj, flags )
	if obj == nil then return abort( "n_netpk:get: obj is nil" ) end

	local class_str = clsid2func[ obj:clsid() ]
		or abort("n_netpk:get: clsid [%d] not found for object [%s] in 'clsid2func'",
			obj:clsid(), obj:name())

	self.state = bit_and( ( flags or 0 ), net_packet.fState ) ~= 0
	self.update = bit_and( ( flags or 0 ), net_packet.fUpdate ) ~= 0
	if not self.state or self.update then
		self.state = true
		self.update = true
	end

--	log( "\n\n! read net_packet for object %s:", obj:name() )
--	log( "state = %s, update = %s", tostring( self.state ), tostring( self.update ) )
	local ret = {}

	ret.net_class_name = class_str

	if self.state then
	--	log( "# state part:" )
		local stpk = net_packet()
		stpk:w_begin( 0 )
		obj:STATE_Write( stpk )
		stpk:r_seek( 2 )
		self[ "r_st_"..class_str ]( self, ret, stpk )
		ret.tail = stpk:r_tail()
	--	table.print( ret )
	end
	
	if self.update then
	--	log( "# update part:" )
		ret.upd = {}
		local uppk = net_packet()
		uppk:w_begin( 0 )
		obj:UPDATE_Write( uppk )
		uppk:r_seek( 2 )
		self[ "r_upd_"..class_str ]( self, ret.upd, uppk )
		ret.upd.tail = uppk:r_tail()
	--	table.print( ret.upd )
	end

	return ret
end

function n_netpk:set( obj, data, flags )
	if not (obj and data) then return abort( "n_netpk:set: obj is nil" ) end

	local class_str = data.net_class_name
		or clsid2func[obj:clsid()]
		or abort("n_netpk:set: clsid [%d] not found for object [%s] in 'clsid2func'",
			obj:clsid(), obj:name())

--	log( "\n\n! write net_packet for object %s:", obj:name() )
--	log( "state = %s, update = %s", tostring( self.state ), tostring( self.update ) )
--	log( "# net_packet data:" )
--	table.print( data )

	if self.state then
		local stpk = net_packet()
		stpk:w_begin( 0 )
		self[ "w_st_"..class_str ]( self, data, stpk )
		stpk:w_tail( data.tail )
		stpk:r_seek( 2 )
		obj:STATE_Read( stpk, stpk:w_tell() )
	end

	if self.update then
		local uppk = net_packet()
		uppk:w_begin( 0 )
		self[ "w_upd_"..class_str ]( self, data.upd, uppk )
		uppk:w_tail( data.upd.tail )
		uppk:r_seek( 2 )
		obj:UPDATE_Read( uppk )
	end

	if bit_and( ( flags or 0 ), net_packet.fConvert ) == 0 then return end

	-- если нужно поместить объект ненадолго в оффлайн для вступления в силу изменений
	local sim = alife()
	if sim then
		local i = obj.id
		local o = level.object_by_id( i )
		if o then
			if class_str=="se_stalker" then o:stop_talk() end
			sim:set_switch_online( i, false )
			sim:set_switch_offline( i, true )
			amk.convert_npc[ i ] = 1
		end
	end
end

function n_netpk:modify( obj, data, flags )
	if not ( obj and data ) then return abort("n_netpk:modify: obj is nil") end

	local class_str = clsid2func[obj:clsid()]
		or abort("n_netpk:modify: clsid [%d] not found for object [%s] in 'clsid2func'",
			obj:clsid(), obj:name())

	local tmp = {}
	local stpk = net_packet()
	local uppk = net_packet()

	self.state = bit_and( ( flags or 0 ), net_packet.fState ) ~= 0
	self.update = bit_and( ( flags or 0 ), net_packet.fUpdate ) ~= 0
	if not self.state or self.update then
		self.state = true
		self.update = true
	end

--	log( "\n\n! modify net_packet for object %s:", obj:name() )
--	log( "state = %s, update = %s", tostring( self.state ), tostring( self.update ) )
	if self.state then
	--	log( "# state part:" )
		stpk:w_begin( 0 )
		obj:STATE_Write( stpk )
		stpk:r_seek( 2 )
		self[ "r_st_"..class_str ]( self, tmp, stpk )
		tmp.tail = stpk:r_tail()
	--	table.print( tmp )
	end

	if self.update then
	--	log( "# update part:" )
		tmp.upd = {}
		uppk:w_begin( 0 )
		obj:UPDATE_Write( uppk )
		uppk:r_seek( 2 )
		self[ "r_upd_"..class_str ]( self, tmp.upd, uppk )
		tmp.upd.tail = uppk:r_tail()
	--	table.print( tmp.upd )
	end

--	log( "~ modify:" )
--	table.print( data )

	table.copy( tmp, data )

	if self.state then
		stpk:w_begin( 0 )
		self[ "w_st_"..class_str ]( self, tmp, stpk )
		stpk:w_tail( tmp.tail )
		stpk:r_seek( 2 )
		obj:STATE_Read( stpk, stpk:w_tell() )
	end

	if self.update then
		uppk:w_begin( 0 )
		self[ "w_upd_"..class_str ]( self, tmp.upd, uppk )
		uppk:w_tail( tmp.upd.tail )
		uppk:r_seek( 2 )
		obj:UPDATE_Read( uppk )
	end

	if bit_and( ( flags or 0 ), net_packet.fConvert ) == 0 then return end

	-- если нужно поместить объект ненадолго в оффлайн для вступления в силу изменений
	local sim = alife()
	if sim then
		local i = obj.id
		local o = level.object_by_id( i )
		if o then
			if class_str=="se_stalker"  then o:stop_talk() end
			sim:set_switch_online( i, false )
			sim:set_switch_offline( i, true )
			amk.convert_npc[ i ] = 1
		end
	end
end
----------------------------------------------------------------------------------------------------------
function n_netpk:create_restrictor( position, level_vertex, game_vertex, logic, radius, story_id )
	local se_obj = alife():create( "space_restrictor", position, level_vertex, game_vertex )

	local data = {}
	data.shapes = {
		[1] = {
			shtype = 0,
			center = vector():set( 0, 0, 0 ),
			radius = radius or 2.0
		}
	}
	data.custom_data = logic
	data.story_id = story_id

	self:modify( se_obj, data, net_packet.fState )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_object
function n_netpk:r_st_cse_alife_object( ret, stpk )
	ret.game_vertex_id  = stpk:r_u16()
	ret.distance        = stpk:r_float()
	ret.direct_control  = stpk:r_s32()
	ret.level_vertex_id	= stpk:r_s32()
	ret.object_flags    = stpk:r_s32()
	ret.custom_data     = stpk:r_stringZ()
	ret.story_id        = stpk:r_s32()
	ret.spawn_story_id  = stpk:r_s32()
end
function n_netpk:w_st_cse_alife_object( data, stpk )
	stpk:w_u16     ( data.game_vertex_id )
	stpk:w_float   ( data.distance )
	stpk:w_s32     ( data.direct_control )
	stpk:w_s32     ( data.level_vertex_id )
	stpk:w_s32     ( data.object_flags )
	stpk:w_stringZ ( data.custom_data )
	stpk:w_s32     ( data.story_id)
	stpk:w_s32     ( data.spawn_story_id )
end
----------------------------------------------------------------------------------------------------------
-- cse_visual
function n_netpk:r_st_cse_visual( ret, stpk )
	ret.visual_name  = stpk:r_stringZ()
	ret.visual_flags = stpk:r_u8()
end
function n_netpk:w_st_cse_visual( data, stpk )
	stpk:w_stringZ ( data.visual_name )
	stpk:w_u8      ( data.visual_flags )
end
----------------------------------------------------------------------------------------------------------
-- cse_motion
function n_netpk:r_st_cse_motion( ret, stpk )
	ret.motion_name = stpk:r_stringZ()
end
function n_netpk:w_st_cse_motion( data, stpk )
	stpk:w_stringZ ( data.motion_name )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_dynamic_object_visual
function n_netpk:r_st_cse_alife_dynamic_object( ret, stpk )
	self:r_st_cse_alife_object ( ret, stpk )
	self:r_st_cse_visual       ( ret, stpk )
end
function n_netpk:r_upd_cse_alife_dynamic_object( ret, uppk ) end
function n_netpk:w_st_cse_alife_dynamic_object( data, stpk )
	self:w_st_cse_alife_object ( data, stpk )
	self:w_st_cse_visual       ( data, stpk )
end
function n_netpk:w_upd_cse_alife_dynamic_object( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_creature_abstract
function n_netpk:r_st_cse_alife_creature_abstract( ret, stpk )
	self:r_st_cse_alife_dynamic_object( ret, stpk )
	
	ret.g_team                   = stpk:r_u8()
	ret.g_squad                  = stpk:r_u8()
	ret.g_group                  = stpk:r_u8()
	ret.health                   = stpk:r_float()
	ret.dynamic_out_restrictions = stpk:r_vu32u16()
	ret.dynamic_in_restrictions  = stpk:r_vu32u16()
	ret.killer_id                = stpk:r_u16()
	ret.game_death_time          = stpk:r_u64()
end
function n_netpk:r_upd_cse_alife_creature_abstract( ret, uppk )
	ret.health         = uppk:r_float()
	ret.timestamp      = uppk:r_s32()
	ret.creature_flags = uppk:r_u8()
	ret.position       = uppk:r_vec3()
	ret.o_model        = uppk:r_float()
	ret.o_torso        = uppk:r_vec3()
	ret.g_team         = uppk:r_u8()
	ret.g_squad        = uppk:r_u8()
	ret.g_group        = uppk:r_u8()
end
function n_netpk:w_st_cse_alife_creature_abstract( data, stpk )
	self:w_st_cse_alife_dynamic_object( data, stpk )

	stpk:w_u8      ( data.g_team )
	stpk:w_u8      ( data.g_squad )
	stpk:w_u8      ( data.g_group )
	stpk:w_float   ( data.health )
	stpk:w_vu32u16 ( data.dynamic_out_restrictions )
	stpk:w_vu32u16 ( data.dynamic_in_restrictions )
	stpk:w_u16     ( data.killer_id )
	stpk:w_u64     ( data.game_death_time )
end
function n_netpk:w_upd_cse_alife_creature_abstract( data, uppk )
	uppk:w_float ( data.health )
	uppk:w_s32   ( data.timestamp )
	uppk:w_u8    ( data.creature_flags )
	uppk:w_vec3  ( data.position )
	uppk:w_float ( data.o_model )
	uppk:w_vec3  ( data.o_torso )
	uppk:w_u8    ( data.g_team )
	uppk:w_u8    ( data.g_squad )
	uppk:w_u8    ( data.g_group )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_monster_abstract
function n_netpk:r_st_cse_alife_monster_abstract( ret, stpk )
	self:r_st_cse_alife_creature_abstract( ret, stpk )
	
	ret.base_out_restrictors      = stpk:r_stringZ()
	ret.base_in_restrictors       = stpk:r_stringZ()
	ret.smart_terrain_id          = stpk:r_u16()
	ret.smart_terrain_task_active = stpk:r_u8()
end
function n_netpk:r_upd_cse_alife_monster_abstract( ret, uppk )
	self:r_upd_cse_alife_creature_abstract( ret, uppk )

	ret.next_game_vertex_id     = uppk:r_u16()
	ret.prev_game_vertex_id     = uppk:r_u16()
	ret.distance_from_point     = uppk:r_s32()
	ret.distance_to_point       = uppk:r_s32()
end
function n_netpk:w_st_cse_alife_monster_abstract( data, stpk )
	self:w_st_cse_alife_creature_abstract( data, stpk )
	
	stpk:w_stringZ ( data.base_out_restrictors )
	stpk:w_stringZ ( data.base_in_restrictors )
	stpk:w_u16     ( data.smart_terrain_id )
	stpk:w_u8      ( data.smart_terrain_task_active )
end
function n_netpk:w_upd_cse_alife_monster_abstract( data, uppk )
	self:w_upd_cse_alife_creature_abstract( data, uppk )
	
	uppk:w_u16 ( data.next_game_vertex_id )
	uppk:w_u16 ( data.prev_game_vertex_id )
	uppk:w_s32 ( data.distance_from_point )
	uppk:w_s32 ( data.distance_to_point )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_trader_abstract
function n_netpk:r_st_cse_alife_trader_abstract( ret, stpk )
	ret.money              = stpk:r_s32()
	ret.specific_character = stpk:r_stringZ()
	ret.trader_flags       = stpk:r_s32()
	ret.character_profile  = stpk:r_stringZ()
	ret.community_index    = stpk:r_s32()
	ret.rank               = stpk:r_s32()
	ret.reputation         = stpk:r_s32()
	ret.character_name     = stpk:r_stringZ()
end
function n_netpk:w_st_cse_alife_trader_abstract( data, stpk )
	stpk:w_s32     ( data.money )
	stpk:w_stringZ ( data.specific_character )
	stpk:w_s32     ( data.trader_flags )
	stpk:w_stringZ ( data.character_profile )
	stpk:w_s32     ( data.community_index )
	stpk:w_s32     ( data.rank )
	stpk:w_s32     ( data.reputation )
	stpk:w_stringZ ( data.character_name )
end
----------------------------------------------------------------------------------------------------------
-- cse_ph_skeleton
function n_netpk:r_st_cse_ph_skeleton( ret, stpk )
	ret.skeleton_name  = stpk:r_stringZ()
	ret.skeleton_flags = stpk:r_u8()
	ret.source_id      = stpk:r_u16()

	if bit_and( ret.skeleton_flags, 4 ) ~= 0 then
		ret.bones_mask  = stpk:r_u64()
		ret.root_bone   = stpk:r_u16()
		ret.bbox_min    = stpk:r_vec3()
		ret.bbox_max    = stpk:r_vec3()
		ret.bones_count = stpk:r_u16()
		if ret.bones_count > 0 then
			ret.bones = {}
			for i = 1, ret.bones_count do
				local t = {}
				t.ph_position = stpk:r_vec_q8()
				t.ph_rotation = stpk:r_qt_q8()
				t.enabled     = stpk:r_u8()
				table.insert ( ret.bones, t )
			end
		end
	end
end
function n_netpk:r_upd_cse_ph_skeleton( ret, uppk )
--	ret.skeleton_flags = uppk:r_u8()
end
function n_netpk:w_st_cse_ph_skeleton( data, stpk )
	stpk:w_stringZ ( data.skeleton_name )
	stpk:w_u8      ( data.skeleton_flags )
	stpk:w_u16     ( data.source_id )

	if bit_and( data.skeleton_flags, 4 ) ~= 0 then
		stpk:w_u64  ( data.bones_mask )
		stpk:w_u16  ( data.root_bone )
		stpk:w_vec3 ( data.bbox_min )
		stpk:w_vec3 ( data.bbox_max )
		stpk:w_u16  ( data.bones_count )
		if data.bones_count > 0 then
			for i, v in ipairs(data.bones) do
				stpk:w_vec_q8 ( v.ph_position )
				stpk:w_qt_q8  ( v.ph_rotation )
				stpk:w_u8     ( v.enabled )
			end
		end
	end
end
function n_netpk:w_upd_cse_ph_skeleton( data, stpk, uppk )
--	uppk:w_u8 ( data.skeleton_flags )
end
----------------------------------------------------------------------------------------------------------
-- cse_shape
function n_netpk:r_st_cse_shape( ret, stpk )
	local sh = {}
	local shape_type
	for i = 1, stpk:r_u8() do
		shape_type = stpk:r_u8()
		if shape_type == 0 then		-- sphere
			sh[i] = { ["shtype"] = shape_type,
				      ["center"] = stpk:r_vec3(),
					  ["radius"] = stpk:r_float() }
		else				-- box
			local m = matrix()
			stpk:r_matrix( m )
			sh[i] = { ["shtype"]     = shape_type,
					  ["box_matrix"] = m }
		end
	end
	ret.shapes = sh
end
function n_netpk:w_st_cse_shape( data, stpk )
	local t = data.shapes
	local n = #t
	stpk:w_u8( n )
	local sh
	for i = 1, n do
		sh = t[i]
		stpk:w_u8( sh.shtype )
		if sh.shtype == 0 then
			stpk:w_vec3( sh.center ); stpk:w_float( sh.radius )
		else
			stpk:w_matrix( sh.box_matrix )
		end
	end
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_ph_skeleton_object
function n_netpk:r_st_cse_alife_ph_skeleton_object( ret, stpk, uppk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )
	self:r_st_cse_ph_skeleton          ( ret, stpk )
end
function n_netpk:r_upd_cse_alife_ph_skeleton_object( ret, uppk ) end
function n_netpk:w_st_cse_alife_ph_skeleton_object( data, stpk )
	write_cse_alife_dynamic_object ( data, stpk )
	write_cse_ph_skeleton          ( data, stpk )
end
function n_netpk:w_upd_cse_alife_ph_skeleton_object( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_creature_actor
function n_netpk:r_st_cse_alife_creature_actor( ret, stpk )
	self:r_st_cse_alife_creature_abstract ( ret, stpk )
	self:r_st_cse_alife_trader_abstract   ( ret, stpk )
	self:r_st_cse_ph_skeleton             ( ret, stpk )

	ret.holder_id				= stpk:r_u16()
end
function n_netpk:r_upd_cse_alife_creature_actor( ret, uppk )
	self:r_upd_cse_alife_creature_abstract ( ret, uppk )

	ret.actor_state           = uppk:r_u16()
	ret.actor_accel_header    = uppk:r_u16()
	ret.actor_accel_data      = uppk:r_s32()
	ret.actor_velocity_header = uppk:r_u16()
	ret.actor_velocity_data   = uppk:r_s32()
	ret.actor_radiation       = uppk:r_float()
	ret.actor_weapon          = uppk:r_u8()
	ret.num_items             = uppk:r_u16()
end
function n_netpk:w_st_cse_alife_creature_actor( data, stpk )
	self:w_st_cse_alife_creature_abstract	( data, stpk )
	self:w_st_cse_alife_trader_abstract		( data, stpk )
	self:w_st_cse_ph_skeleton				( data, stpk )

	stpk:w_u16	( data.holder_id )
end
function n_netpk:w_upd_cse_alife_creature_actor( data, uppk )
	self:w_upd_cse_alife_creature_abstract	( data, uppk )
	uppk:w_u16	( data.actor_state )
	uppk:w_u16	( data.actor_accel_header )
	uppk:w_s32	( data.actor_accel_data )
	uppk:w_u16	( data.actor_velocity_header )
	uppk:w_s32	( data.actor_velocity_data )
	uppk:w_float( data.actor_radiation )
	uppk:w_u8	( data.actor_weapon )
	uppk:w_u16	( data.num_items )
end
----------------------------------------------------------------------------------------------------------
-- se_stalker
function n_netpk:r_st_se_stalker( ret, stpk )
	self:r_st_cse_alife_trader_abstract  ( ret, stpk )
	self:r_st_cse_alife_monster_abstract ( ret, stpk )

	-- cse_alife_human_abstract
	ret.predicate5  = stpk:r_vu32u8()
	ret.predicate4  = stpk:r_vu32u8()

	self:r_st_cse_ph_skeleton ( ret, stpk )

	-- se_stalker
	local a = stpk:r_u8()
	if a == 3 then ret.job_online_condlist = stpk:r_stringZ() end
	ret.job_online           = a
	ret.was_in_smart_terrain = stpk:r_u8()
	ret.death_dropped        = stpk:r_u8()
	ret.resupply_time        = (stpk:r_eof() and 0) or stpk:r_s16()
end
function n_netpk:r_upd_se_stalker( ret, uppk )
	self:r_upd_cse_alife_monster_abstract ( ret, uppk )

	-- cse_alife_human_stalker
	ret.start_dialog = uppk:r_stringZ()
end
function n_netpk:w_st_se_stalker( data, stpk )
	self:w_st_cse_alife_trader_abstract  ( data, stpk )
	self:w_st_cse_alife_monster_abstract ( data, stpk )

	-- cse_alife_human_abstract
	stpk:w_vu32u8 ( data.predicate5 )
	stpk:w_vu32u8 ( data.predicate4 )

	self:w_st_cse_ph_skeleton ( data, stpk )

	-- se_stalker
	stpk:w_u8  ( data.job_online )
	if data.job_online == 3 then stpk:w_stringZ ( data.job_online_condlist ) end
	stpk:w_u8  ( data.was_in_smart_terrain )
	stpk:w_u8  ( data.death_dropped )
	stpk:w_s16 ( data.resupply_time )
end
function n_netpk:w_upd_se_stalker( data, uppk )
	self:w_upd_cse_alife_monster_abstract ( data, uppk )

	-- cse_alife_human_stalker
	uppk:w_stringZ ( data.start_dialog )
end
----------------------------------------------------------------------------------------------------------
-- se_monster
function n_netpk:r_st_se_monster( ret, stpk )
	self:r_st_cse_alife_monster_abstract ( ret, stpk )
	self:r_st_cse_ph_skeleton            ( ret, stpk )

	-- cse_alife_monster_base
	ret.spec_object_id = stpk:r_u16()

	-- se_monster
	local n = stpk:r_u8()
	if n >= 4 then
		ret.state = true
		n = n - 4
	else
		ret.state = false
	end
	ret.job_online = n
	if n == 3 then ret.job_online_condlist = stpk:r_stringZ() end
	ret.was_in_smart_terrain = stpk:r_u8()
end
function n_netpk:r_upd_se_monster( ret, uppk )
	self:r_upd_cse_alife_monster_abstract ( ret, uppk )
end
function n_netpk:w_st_se_monster( data, stpk )
	self:w_st_cse_alife_monster_abstract ( data, stpk )
	self:w_st_cse_ph_skeleton            ( data, stpk )

	-- cse_alife_monster_base
	stpk:w_u16 ( data.spec_object_id )

	-- se_monster
	local n = data.job_online
	if data.state then stpk:w_u8( n + 4 )
	else stpk:w_u8( n ) end
	if n == 3 then stpk:w_stringZ ( data.job_online_condlist ) end
	stpk:w_u8 ( data.was_in_smart_terrain )
end
function n_netpk:w_upd_se_monster( data, uppk )
	self:w_upd_cse_alife_monster_abstract ( data, uppk )
end
----------------------------------------------------------------------------------------------------------
-- se_trader
function n_netpk:r_st_se_trader( ret, stpk )
	self:r_st_cse_alife_dynamic_object  ( ret, stpk )
	self:r_st_cse_alife_trader_abstract ( ret, stpk )

	-- se_trader
	ret.resupply_time = ( stpk:r_eof() and 0 ) or stpk:r_s16()
end
function n_netpk:r_upd_se_trader( ret, uppk ) end
function n_netpk:w_st_se_trader( data, stpk )
	self:w_st_cse_alife_dynamic_object  ( data, stpk )
	self:w_st_cse_alife_trader_abstract ( data, stpk )

	-- se_trader
	stpk:w_s16 ( data.resupply_time )
end
function n_netpk:w_upd_se_trader( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_heli
function n_netpk:r_st_se_heli( ret, stpk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )
	self:r_st_cse_motion               ( ret, stpk )
	self:r_st_cse_ph_skeleton          ( ret, stpk )

	-- cse_alife_helicopter
	ret.startup_animation = stpk:r_stringZ()
	ret.engine_sound      = stpk:r_stringZ()
end
function n_netpk:r_upd_se_heli( ret, uppk ) end
function n_netpk:w_st_se_heli( data, stpk )
	self:w_st_cse_alife_dynamic_object ( data, stpk )
	self:w_st_cse_motion               ( data, stpk )
	self:w_st_cse_ph_skeleton          ( data, stpk )

	-- cse_alife_helicopter
	stpk:w_stringZ ( data.startup_animation )
	stpk:w_stringZ ( data.engine_sound )
end
function n_netpk:w_upd_se_heli( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_car
function n_netpk:r_st_se_car( ret, stpk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )
	self:r_st_cse_ph_skeleton          ( ret, stpk )

	-- cse_alife_car
	ret.health = stpk:r_float()
end
function n_netpk:r_upd_se_car( ret, uppk ) end
function n_netpk:w_st_se_car( data, stpk )
	self:w_st_cse_alife_dynamic_object ( data, stpk )
	self:w_st_cse_ph_skeleton          ( data, stpk )

	-- cse_alife_car
	stpk:w_float ( data.health )
end
function n_netpk:w_upd_se_car( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_inventory_item
function n_netpk:r_st_cse_alife_inventory_item( ret, stpk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )

	-- cse_alife_item
	ret.condition = stpk:r_float()
end
function n_netpk:r_upd_cse_alife_inventory_item( ret, uppk )
	local n = uppk:r_u8()
	ret.num_items = n
	if n ~= 0 then
		ret.ph_position = uppk:r_vec3()
		ret.ph_rotation = uppk:r_qt_q8()
		if bit_and(n, 64) == 64 then
			ret.ph_angular_vel = uppk:r_vec_q8()
		end
		if bit_and(n, 128) == 128 then
			ret.ph_linear_vel = uppk:r_vec_q8()
		end
	end
end
function n_netpk:w_st_cse_alife_inventory_item( data, stpk )
	self:w_st_cse_alife_dynamic_object( data, stpk )

	-- cse_alife_item
	stpk:w_float( data.condition )
end
function n_netpk:w_upd_cse_alife_inventory_item( data, uppk )
	local n = data.num_items
	uppk:w_u8( n )
	if n ~= 0 then
		uppk:w_vec3  ( data.ph_position )
		uppk:w_qt_q8 ( data.ph_rotation )
		if bit_and(n, 64) == 64 then
			uppk:w_vec_q8 ( data.ph_angular_vel )
		end
		if bit_and(n, 128) == 128 then
			uppk:w_vec_q8 ( data.ph_linear_vel )
		end
	end
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_pda
function n_netpk:r_st_cse_alife_item_pda( ret, stpk )
	self:r_st_cse_alife_inventory_item ( ret, stpk )

	-- cse_alife_item_pda
	ret.original_owner     = stpk:r_u16()
	ret.specific_character = stpk:r_stringZ()
	ret.info_portion       = stpk:r_stringZ()
end
function n_netpk:r_upd_cse_alife_item_pda( ret, uppk )
	self:r_upd_cse_alife_inventory_item ( ret, uppk )
end
function n_netpk:w_st_cse_alife_item_pda( data, stpk )
	self:w_st_cse_alife_inventory_item ( data, stpk )

	-- cse_alife_item_pda
	stpk:w_u16     ( data.original_owner )
	stpk:w_stringZ ( data.specific_character )
	stpk:w_stringZ ( data.info_portion )
end
function n_netpk:w_upd_cse_alife_item_pda( data, uppk )
	self:w_upd_cse_alife_inventory_item ( data, uppk )
end
----------------------------------------------------------------------------------------------------------
-- se_item_torch
function n_netpk:r_st_se_item_torch( ret, stpk )
	self:r_st_cse_alife_inventory_item ( ret, stpk )

	-- se_item_torch
	ret.worked_time = (stpk:r_eof() and 0) or stpk:r_s32()
end
function n_netpk:r_upd_se_item_torch( ret, uppk )
	self:r_upd_cse_alife_inventory_item ( ret, uppk )

	-- cse_alife_item_torch
	ret.torch_flags = uppk:r_u8()
end
function n_netpk:w_st_se_item_torch( data, stpk )
	self:w_st_cse_alife_inventory_item ( data, stpk )

	-- se_item_torch
	stpk:w_s32 (data.worked_time)
end
function n_netpk:w_upd_se_item_torch( data, uppk )
	self:w_upd_cse_alife_inventory_item ( data, uppk )

	-- cse_alife_item_torch
	uppk:w_u8 ( data.torch_flags )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_document
function n_netpk:r_st_cse_alife_item_document( ret, stpk )
	self:r_st_cse_alife_inventory_item ( ret, stpk )

	-- cse_alife_item_document
	ret.info_portion = stpk:r_stringZ()
end
function n_netpk:r_upd_cse_alife_item_document( ret, uppk )
	self:r_upd_cse_alife_inventory_item ( ret, uppk )
end
function n_netpk:w_st_cse_alife_item_document( data, stpk )
	self:w_st_cse_alife_inventory_item ( data, stpk )

	-- cse_alife_item_document
	stpk:w_stringZ ( data.info_portion )
end
function n_netpk:w_upd_cse_alife_item_document( data, uppk )
	self:w_upd_cse_alife_inventory_item ( data, uppk )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_custom_outfit
function n_netpk:r_st_cse_alife_item_custom_outfit( ret, stpk )
	self:r_st_cse_alife_inventory_item ( ret, stpk )
end
function n_netpk:r_upd_cse_alife_item_custom_outfit( ret, uppk )
	self:r_upd_cse_alife_inventory_item ( ret, uppk )

	-- cse_alife_item_custom_outfit
	ret.condition = uppk:r_u8()
end
function n_netpk:w_st_cse_alife_item_custom_outfit( data, stpk )
	self:w_st_cse_alife_inventory_item ( data, stpk )
end
function n_netpk:w_upd_cse_alife_item_custom_outfit( data, uppk )
	self:w_upd_cse_alife_inventory_item ( data, uppk )

	-- cse_alife_item_custom_outfit
	uppk:w_u8 ( data.condition )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_ammo
function n_netpk:r_st_cse_alife_item_ammo( ret, stpk )
	self:r_st_cse_alife_inventory_item ( ret, stpk )

	-- cse_alife_item_ammo
	ret.ammo_left         = stpk:r_u16()
end
function n_netpk:r_upd_cse_alife_item_ammo( ret, uppk )
	self:r_upd_cse_alife_inventory_item ( ret, uppk )

	-- cse_alife_item_ammo
	ret.ammo_left = uppk:r_u16()
end
function n_netpk:w_st_cse_alife_item_ammo( data, stpk )
	self:w_st_cse_alife_inventory_item ( data, stpk )

	-- cse_alife_item_ammo
	stpk:w_u16 ( data.ammo_left )
end
function n_netpk:w_upd_cse_alife_item_ammo( data, uppk )
	self:w_upd_cse_alife_inventory_item ( data, uppk )

	-- cse_alife_item_ammo
	uppk:w_u16 ( data.ammo_left )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_weapon
function n_netpk:r_st_cse_alife_item_weapon( ret, stpk )
	self:r_st_cse_alife_inventory_item ( ret, stpk )

	-- cse_alife_item_weapon
	ret.ammo_current   = stpk:r_u16()
	ret.ammo_elapsed   = stpk:r_u16()
	ret.weapon_state   = stpk:r_u8()
	ret.addon_flags    = stpk:r_u8()
	ret.ammo_type      = stpk:r_u8()
end
function n_netpk:r_upd_cse_alife_item_weapon( ret, uppk )
	self:r_upd_cse_alife_inventory_item ( ret, uppk )

	-- cse_alife_item_weapon
	ret.condition    = uppk:r_u8()
	ret.weapon_flags = uppk:r_u8()
	ret.ammo_elapsed = uppk:r_u16()
	ret.addon_flags  = uppk:r_u8()
	ret.ammo_type    = uppk:r_u8()
	ret.weapon_state = uppk:r_u8()
	ret.weapon_zoom  = uppk:r_u8()
end
function n_netpk:w_st_cse_alife_item_weapon( data, stpk )
	self:w_st_cse_alife_inventory_item ( data, stpk )

	-- cse_alife_item_weapon
	stpk:w_u16 ( data.ammo_current )
	stpk:w_u16 ( data.ammo_elapsed )
	stpk:w_u8  ( data.weapon_state )
	stpk:w_u8  ( data.addon_flags )
	stpk:w_u8  ( data.ammo_type )
end
function n_netpk:w_upd_cse_alife_item_weapon( data, uppk )
	self:w_upd_cse_alife_inventory_item ( data, uppk )

	-- cse_alife_item_weapon
	uppk:w_u8  ( data.condition )
	uppk:w_u8  ( data.weapon_flags )
	uppk:w_u16 ( data.ammo_elapsed )
	uppk:w_u8  ( data.addon_flags )
	uppk:w_u8  ( data.ammo_type )
	uppk:w_u8  ( data.weapon_state )
	uppk:w_u8  ( data.weapon_zoom )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_weapon_magazined
function n_netpk:r_st_cse_alife_item_weapon_magazined( ret, stpk )
	self:r_st_cse_alife_item_weapon ( ret, stpk )
end
function n_netpk:r_upd_cse_alife_item_weapon_magazined( ret, uppk )
	self:r_upd_cse_alife_item_weapon ( ret, uppk )

	-- cse_alife_item_weapon_magazined
	ret.current_fire_mode = uppk:r_u8()
end
function n_netpk:w_st_cse_alife_item_weapon_magazined( data, stpk )
	self:w_st_cse_alife_item_weapon ( data, stpk )
end
function n_netpk:w_upd_cse_alife_item_weapon_magazined( data, uppk )
	self:w_upd_cse_alife_item_weapon ( data, uppk )

	-- cse_alife_item_weapon_magazined
	uppk:w_u8 ( data.current_fire_mode )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_weapon_shotgun
function n_netpk:r_st_cse_alife_item_weapon_shotgun( ret, stpk )
	self:r_st_cse_alife_item_weapon_magazined ( ret, stpk )
end
function n_netpk:r_upd_cse_alife_item_weapon_shotgun( ret, uppk )
	self:r_upd_cse_alife_item_weapon_magazined ( ret, uppk )

	-- cse_alife_item_weapon_shotgun
	ret.ammo_ids = uppk:r_vu8u8()
end
function n_netpk:w_st_cse_alife_item_weapon_shotgun( data, stpk )
	self:w_st_cse_alife_item_weapon_magazined ( data, stpk )
end
function n_netpk:w_upd_cse_alife_item_weapon_shotgun( data, uppk )
	self:w_upd_cse_alife_item_weapon_magazined ( data, uppk )

	-- cse_alife_item_weapon_shotgun
	uppk:w_vu8u8 ( data.ammo_ids )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_item_weapon_magazined_w_gl
function n_netpk:r_st_cse_alife_item_weapon_magazined_w_gl( ret, stpk )
	self:r_st_cse_alife_item_weapon_magazined ( ret, stpk )
end
function n_netpk:r_upd_cse_alife_item_weapon_magazined_w_gl( ret, uppk )
	-- cse_alife_item_weapon_magazined_w_gl
	ret.grenade_mode = uppk:r_u8()

	self:r_upd_cse_alife_item_weapon_magazined ( ret, uppk )
end
function n_netpk:w_st_cse_alife_item_weapon_magazined_w_gl( data, stpk )
	self:w_st_cse_alife_item_weapon_magazined ( data, stpk )
end
function n_netpk:w_upd_cse_alife_item_weapon_magazined_w_gl( data, uppk )
	-- cse_alife_item_weapon_magazined_w_gl
	uppk:w_u8 ( data.grenade_mode )

	self:w_upd_cse_alife_item_weapon_magazined ( data, uppk )
end
----------------------------------------------------------------------------------------------------------
-- cse_alife_object_breakable
function n_netpk:r_st_cse_alife_object_breakable( ret, stpk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )
	
	-- cse_alife_object_breakable
	ret.health = stpk:r_float()
end
function n_netpk:r_upd_cse_alife_object_breakable( ret, uppk ) end
function n_netpk:w_st_cse_alife_object_breakable( data, stpk )
	self:w_st_cse_alife_dynamic_object ( data, stpk )
	
	-- cse_alife_object_breakable
	stpk:w_float ( data.health )
end
function n_netpk:w_upd_cse_alife_object_breakable( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_object_physic
function n_netpk:r_st_cse_alife_object_physic( ret, stpk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )
	self:r_st_cse_ph_skeleton          ( ret, stpk )
	
	-- cse_alife_object_physic
	ret.physic_type = stpk:r_s32()
	ret.mass        = stpk:r_float()
	ret.fixed_bones = stpk:r_stringZ()
end
function n_netpk:r_upd_cse_alife_object_physic( ret, uppk ) end
function n_netpk:w_st_cse_alife_object_physic( data, stpk )
	self:w_st_cse_alife_dynamic_object ( data, stpk )
	self:w_st_cse_ph_skeleton          ( data, stpk )
	
	-- cse_alife_object_physic
	stpk:w_s32     ( data.physic_type )
	stpk:w_float   ( data.mass )
	stpk:w_stringZ ( data.fixed_bones )
end
function n_netpk:w_upd_cse_alife_object_physic( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_object_hanging_lamp
function n_netpk:r_st_cse_alife_object_hanging_lamp( ret, stpk )
	self:r_st_cse_alife_dynamic_object ( ret, stpk )
	self:r_st_cse_ph_skeleton          ( ret, stpk )
	
	-- cse_alife_object_hanging_lamp
	ret.main_color          = stpk:r_s32()
	ret.main_brightness     = stpk:r_float()
	ret.main_color_animator = stpk:r_stringZ()
	ret.main_range          = stpk:r_float()
	ret.light_flags         = stpk:r_u16()
	ret.startup_animation   = stpk:r_stringZ()
	ret.lamp_fixed_bones    = stpk:r_stringZ()
	ret.health              = stpk:r_float()
	ret.main_virtual_size   = stpk:r_float()
	ret.ambient_radius      = stpk:r_float()
	ret.ambient_power       = stpk:r_float()
	ret.ambient_texture     = stpk:r_stringZ()
	ret.main_texture        = stpk:r_stringZ()
	ret.main_bone           = stpk:r_stringZ()
	ret.main_cone_angle     = stpk:r_float()
	ret.glow_texture        = stpk:r_stringZ()
	ret.glow_radius         = stpk:r_float()
	ret.ambient_bone        = stpk:r_stringZ()
end
function n_netpk:r_upd_cse_alife_object_hanging_lamp( ret, uppk ) end
function n_netpk:w_st_cse_alife_object_hanging_lamp( data, stpk )
	self:w_st_cse_alife_dynamic_object ( data, stpk )
	self:w_st_cse_ph_skeleton          ( data, stpk )
	
	-- cse_alife_object_hanging_lamp
	stpk:w_s32     ( data.main_color )
	stpk:w_float   ( data.main_brightness )
	stpk:r_stringZ ( data.main_color_animator )
	stpk:w_float   ( data.main_range )
	stpk:w_u16     ( data.light_flags )
	stpk:r_stringZ ( data.startup_animation )
	stpk:r_stringZ ( data.lamp_fixed_bones )
	stpk:w_float   ( data.health )
	stpk:w_float   ( data.main_virtual_size )
	stpk:w_float   ( data.ambient_radius )
	stpk:w_float   ( data.ambient_power )
	stpk:r_stringZ ( data.ambient_texture )
	stpk:r_stringZ ( data.main_texture )
	stpk:r_stringZ ( data.main_bone )
	stpk:w_float   ( data.main_cone_angle )
	stpk:r_stringZ ( data.glow_texture )
	stpk:w_float   ( data.glow_radius )
	stpk:r_stringZ ( data.ambient_bone )
end
function n_netpk:w_upd_cse_alife_object_hanging_lamp( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_object_climable
function n_netpk:r_st_cse_alife_object_climable( ret, stpk )
	self:r_st_cse_alife_object ( ret, stpk )
	self:r_st_cse_shape        ( ret, stpk )
	
	-- cse_alife_object_climable
	ret.game_material     = stpk:r_stringZ()
end
function n_netpk:r_upd_cse_alife_object_climable( ret, uppk ) end
function n_netpk:w_st_cse_alife_object_climable( data, stpk )
	self:w_st_cse_alife_object ( data, stpk )
	self:w_st_cse_shape        ( data, stpk )
	
	-- cse_alife_object_climable
	stpk:w_stringZ         ( data.game_material )
end
function n_netpk:w_upd_cse_alife_object_climable( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_space_restrictor
function n_netpk:r_st_cse_alife_space_restrictor( ret, stpk )
	self:r_st_cse_alife_object ( ret, stpk )
	self:r_st_cse_shape        ( ret, stpk )
	
	-- cse_alife_space_restrictor
	ret.restrictor_type   = stpk:r_u8()
end
function n_netpk:r_upd_cse_alife_space_restrictor( ret, uppk ) end
function n_netpk:w_st_cse_alife_space_restrictor( data, stpk )
	self:w_st_cse_alife_object ( data, stpk )
	self:w_st_cse_shape        ( data, stpk )
	
	-- cse_alife_space_restrictor
	stpk:w_u8              ( data.restrictor_type )
end
function n_netpk:w_upd_cse_alife_space_restrictor( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_restrictor
function n_netpk:r_st_se_restrictor( ret, stpk )
	self:r_st_cse_alife_space_restrictor( ret, stpk )

	-- se_restrictor
	ret.activated = stpk:r_bool()
end
function n_netpk:r_upd_se_restrictor( ret, uppk ) end
function n_netpk:w_st_se_restrictor( data, stpk, uppk )
	self:w_st_cse_alife_space_restrictor( data, stpk )

	-- se_restrictor
	stpk:w_bool( data.activated )
end
function n_netpk:w_upd_se_restrictor( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_level_changer
function n_netpk:r_st_cse_alife_level_changer( ret, stpk )
	self:r_st_cse_alife_space_restrictor( ret, stpk )
	
	-- cse_alife_level_changer
	ret.dest_game_vertex_id  = stpk:r_u16()
	ret.dest_level_vertex_id = stpk:r_s32()
	ret.dest_position        = stpk:r_vec3()
	ret.dest_direction       = stpk:r_vec3()
	ret.dest_level_name      = stpk:r_stringZ()
	ret.dest_graph_point     = stpk:r_stringZ()
	ret.silent_mode          = stpk:r_u8()
end
function n_netpk:r_upd_cse_alife_level_changer( ret, uppk ) end
function n_netpk:w_st_cse_alife_level_changer( data, stpk )
	self:w_st_cse_alife_space_restrictor( data, stpk )
	
	-- cse_alife_level_changer
	stpk:w_u16     ( data.dest_game_vertex_id )
	stpk:w_s32     ( data.dest_level_vertex_id )
	stpk:w_vec3    ( data.dest_position )
	stpk:w_vec3    ( data.dest_direction )
	stpk:w_stringZ ( data.dest_level_name )
	stpk:w_stringZ ( data.dest_graph_point )
	stpk:w_u8      ( data.silent_mode )
end
function n_netpk:w_upd_cse_alife_level_changer( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_anomalous_zone
function n_netpk:r_st_cse_alife_anomalous_zone( ret, stpk )
	self:r_st_cse_alife_space_restrictor( ret, stpk )
	
	-- cse_alife_custom_zone
	ret.max_power        = stpk:r_float()
	ret.owner_id         = stpk:r_s32()
	ret.enabled_time     = stpk:r_s32()
	ret.disabled_time    = stpk:r_s32()
	ret.start_time_shift = stpk:r_s32()
	
	-- cse_alife_anomalous_zone
	ret.offline_interactive_radius = stpk:r_float()
	ret.artefact_spawn_count       = stpk:r_u16()
	ret.artefact_position_offset   = stpk:r_s32()
end
function n_netpk:r_upd_cse_alife_anomalous_zone( ret, uppk ) end
function n_netpk:w_st_cse_alife_anomalous_zone( data, stpk )
	self:w_st_cse_alife_space_restrictor( data, stpk )
	
	-- cse_alife_custom_zone
	stpk:w_float ( data.max_power )
	stpk:w_s32   ( data.owner_id )
	stpk:w_s32   ( data.enabled_time )
	stpk:w_s32   ( data.disabled_time )
	stpk:w_s32   ( data.start_time_shift )
	
	-- cse_alife_anomalous_zone
	stpk:w_float ( data.offline_interactive_radius )
	stpk:w_u16   ( data.artefact_spawn_count )
	stpk:w_s32   ( data.artefact_position_offset )
end
function n_netpk:w_upd_cse_alife_anomalous_zone( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_zone_anom
function n_netpk:r_st_se_zone_anom( ret, stpk )
	self:r_st_cse_alife_anomalous_zone( ret, stpk )
	
	-- se_zone_anom
	local n = stpk:r_u8()
	ret.last_spawn_time_present = n
	if n == 1 then
		ret.last_spawn_time = stpk:r_CTime()
	end
end
function n_netpk:r_upd_se_zone_anom( ret, uppk ) end
function n_netpk:w_st_se_zone_anom( data, stpk )
	self:w_st_cse_alife_anomalous_zone ( data, stpk )

	-- se_zone_anom
	stpk:w_u8( data.last_spawn_time_present )
	if data.last_spawn_time_present == 1 then
		stpk:w_CTime ( data.last_spawn_time )
	end
end
function n_netpk:w_upd_se_zone_anom( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_zone_visual
function n_netpk:r_st_cse_alife_zone_visual( ret, stpk, uppk )
	self:r_st_cse_alife_anomalous_zone( ret, stpk, uppk )
	self:r_st_cse_visual( ret, stpk )

	-- cse_alife_zone_visual
	ret.idle_animation		= stpk:r_stringZ()
	ret.attack_animation	= stpk:r_stringZ()
end
function n_netpk:r_upd_cse_alife_zone_visual( ret, uppk ) end
function n_netpk:w_st_cse_alife_zone_visual( data, stpk )
	self:w_st_cse_alife_anomalous_zone( data, stpk )
	self:w_st_cse_visual( data, stpk )

	-- cse_alife_zone_visual
	stpk:w_stringZ( data.idle_animation )
	stpk:w_stringZ( data.attack_animation )
end
function n_netpk:w_upd_cse_alife_zone_visual( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_zone_visual
function n_netpk:r_st_se_zone_visual( ret, stpk )
	self:r_st_cse_alife_zone_visual( ret, stpk )

	-- se_zone_visual
	local n = stpk:r_u8()
	ret.last_spawn_time_present = n
	if n == 1 then
		ret.last_spawn_time = stpk:r_CTime()
	end
end
function n_netpk:r_upd_se_zone_visual( ret, uppk ) end
function n_netpk:w_st_se_zone_visual( data, stpk )
	self:w_st_cse_alife_zone_visual( data, stpk )

	-- se_zone_visual
	stpk:w_u8( data.last_spawn_time_present )
	if data.last_spawn_time_present == 1 then
		stpk:w_CTime ( data.last_spawn_time )
	end
end
function n_netpk:w_upd_se_zone_visual( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- cse_alife_torrid_zone
function n_netpk:r_st_cse_alife_torrid_zone( ret, stpk )
	self:r_st_cse_alife_anomalous_zone( ret, stpk )
	self:r_st_cse_motion( ret, stpk )
end
function n_netpk:r_upd_cse_alife_torrid_zone( ret, uppk ) end
function n_netpk:w_st_cse_alife_torrid_zone( data, stpk )
	self:w_st_cse_alife_anomalous_zone( data, stpk )
	self:w_st_cse_motion( data, stpk )
end
function n_netpk:w_upd_cse_alife_torrid_zone( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_respawn
function n_netpk:r_st_se_respawn( ret, stpk )
	self:r_st_cse_alife_space_restrictor( ret, stpk )
	
	-- se_respawn
	local n = stpk:r_u8()
	ret.spawned_obj = {}
	if n > 0 then
		for  i = 1, n do
			table.insert( ret.spawned_obj, stpk:r_u16() )
		end
	end
	if not stpk:r_eof() then
		ret.respawn_time = stpk:r_CTime( )
	end
end
function n_netpk:r_upd_se_respawn( ret, uppk ) end
function n_netpk:w_st_se_respawn( data, stpk )
	self:w_st_cse_alife_space_restrictor( data, stpk )
	
	-- se_respawn
	local n = #data.spawned_obj
	stpk:w_u8( n )
	for i, v in ipairs( data.spawned_obj ) do
		stpk:w_u16( v )
	end
	if data.respawn_time then
		stpk:w_CTime( data.respawn_time )
	end
end
function n_netpk:w_upd_se_respawn( data, uppk ) end
----------------------------------------------------------------------------------------------------------
-- se_smart_terrain
function n_netpk:r_st_se_smart_terrain( ret, stpk )
	self:r_st_cse_alife_space_restrictor( ret, stpk )
	
	-- se_smart_terrain
	ret.duration_end_present	= stpk:r_CTime()
	ret.idle_end_present		= stpk:r_CTime()
	ret.gulag_working			= stpk:r_u8()	-- r_bool
	if ret.gulag_working ~= 0 then
		-- gulag:load_common
		local t = {}
		ret.gulag = t
		t.Object_begin_job			= {}
		t.Object_didnt_begin_job	= {}
		t.ObjectJob					= {}
		t.casualities 		= stpk:r_u8()
		t.state       		= stpk:r_u8()
		t.stateBegin 		= stpk:r_CTime()
		t.population				= stpk:r_u8()
		t.population_comed			= stpk:r_u8()
		t.population_non_exclusive	= stpk:r_u8()
		t.loaded_jobs = {}
		local job
		for i = 1, stpk:r_u8() do
			job = {}
			table.insert( t.loaded_jobs, job )
			job.begin            = stpk:r_u32()
			job.fill_idle        = stpk:r_u32()
			job.idle_after_death_end = stpk:r_u32()
		end
		-- read npc_info
		ret.npc_info = {}
		local o_id
		for i = 1, stpk:r_u8() do
			o_id = stpk:r_u16()
			local o = {}
			ret.npc_info[o_id] = o
			o.o_group   = stpk:r_u8()
			o.o_squad   = stpk:r_u8()
			o.exclusive = stpk:r_bool()
			o.stay_end  = stpk:r_CTime()
			-- gulag:load_obj
			t.Object_begin_job[o_id] = stpk:r_bool()
			t.Object_didnt_begin_job[o_id] = stpk:r_bool()
			t.ObjectJob[o_id] = stpk:r_u8()
		end
		ret.population_locked = stpk:r_bool()
	end
end
function n_netpk:r_upd_se_smart_terrain( ret, uppk ) end
function n_netpk:w_st_se_smart_terrain( data, stpk )
	self:w_st_cse_alife_space_restrictor( data, stpk )
	
	-- se_smart_terrain
	stpk:w_CTime( data.duration_end_present )
	stpk:w_CTime( data.idle_end_present )
	stpk:w_u8( data.gulag_working )
	if data.gulag_working ~= 0 then
		-- gulag:save_common
		local t = data.gulag
		stpk:w_u8( t.casualities )
		stpk:w_u8( t.state )
		stpk:w_CTime( t.stateBegin )
		stpk:w_u8(t.population)
		stpk:w_u8(t.population_comed)
		stpk:w_u8(t.population_non_exclusive)
		stpk:w_u8( #t.loaded_jobs )
		for i, job in ipairs(t.loaded_jobs) do
			stpk:w_u32( job.begin )
			stpk:w_u32( job.fill_idle )
			stpk:w_u32( job.idle_after_death_end )
		end
		-- write npc_info
		stpk:w_u8( table.size(data.npc_info) )
		for id, v in pairs( data.npc_info ) do
			stpk:w_u16  ( id )
			stpk:w_u8   ( v.o_group )
			stpk:w_u8   ( v.o_squad )
			stpk:w_bool ( v.exclusive )
			stpk:w_CTime ( v.stay_end )
			-- gulag:save_obj
			stpk:w_bool ( t.Object_begin_job[id] )
			stpk:w_bool ( t.Object_didnt_begin_job[id] )
			stpk:w_u8   ( t.ObjectJob[id] )
		end
		stpk:w_bool ( data.population_locked )
	end
end
function n_netpk:w_upd_se_smart_terrain( data, uppk ) end
----------------------------------------------------------------------------------------------
-- Парсим custom_data в таблицу
function n_netpk:parse_custom_data(str)
	local ret = {}
	local s,v
	local now_sect = ""
	for line in string.gfind(str, "([^\n]+)\n*") do
		s = string.match(line, "^%s*(%b[])")
		if s then
			s = s:sub(2, -2)
			ret[s] = {}
			now_sect = s
		elseif now_sect~="" then
			s, v = string.match(line, "^%s*([%w%-%._]+)%s*=*%s*([^;]*)")
			s = s and trim(s) or ""
			if s~=nil and s~="" then
				v = v and trim(v) or "<nil>"
				ret[now_sect][s] = v~="" and v or "<nil>"
			end
		end
	end
	return ret
end
-- Генерируем из таблицы строку для custom_data
function n_netpk:gen_custom_data(tbl)
	local ret = ""
	for k,v in pairs(tbl) do
		ret = ret.."["..k.."]\n"
		for kk,vv in pairs(v) do
			ret = ret..kk..(vv=="<nil>" and "\n" or " = "..vv.."\n")
		end
	end
	return ret
end
------ OGSE + -------------------------------------------------------------------------------
function mul_43(res, m1, m2)
	if res.mul_43 then
		res:mul_43(m1, m2)
	else
		local res_00 = m1.j.x * m2.i.y + m1.k.x * m2.i.z + m1.i.x * m2.i.x;
		local res_01 = m1.j.y * m2.i.y + m1.k.y * m2.i.z + m1.i.y * m2.i.x;
		local res_02 = m1.j.z * m2.i.y + m1.k.z * m2.i.z + m1.i.z * m2.i.x;
		--
		local res_10 = m1.i.x * m2.j.x + m1.k.x * m2.j.z + m1.j.x * m2.j.y;
		local res_11 = m1.k.y * m2.j.z + m1.j.y * m2.j.y + m1.i.y * m2.j.x;
		local res_12 = m1.k.z * m2.j.z + m1.j.z * m2.j.y + m1.i.z * m2.j.x;
		--
		local res_20 = m1.i.x * m2.k.x + m1.k.x * m2.k.z + m1.j.x * m2.k.y;
		local res_21 = m1.k.y * m2.k.z + m1.j.y * m2.k.y + m1.i.y * m2.k.x;
		local res_22 = m1.k.z * m2.k.z + m1.j.z * m2.k.y + m1.i.z * m2.k.x;
		--
		local res_30 = m1.i.x * m2.c.x + m1.k.x * m2.c.z + m1.j.x * m2.c.y + m1.c.x;
		local res_31 = m1.k.y * m2.c.z + m1.j.y * m2.c.y + m1.i.y * m2.c.x + m1.c.y;
		local res_32 = m1.k.z * m2.c.z + m1.j.z * m2.c.y + m1.i.z * m2.c.x + m1.c.z;
		--
		res:set(
			vector():set(res_00, res_01, res_02),
			vector():set(res_10, res_11, res_12),
			vector():set(res_20, res_21, res_22),
			vector():set(res_30, res_31, res_32)
			)
		res._14_ = 0.0
		res._24_ = 0.0
		res._34_ = 0.0
		res._44_ = 1.0
	end
	return res
end

function transform_tiny(m, v)
	local res = vector()
	return transform_tiny_(m, res, v)
end
function transform_tiny_(m, res, v)
	res.x = m.i.x * v.x + m.k.x * v.z + m.j.x * v.y + m.c.x;
	res.y = m.k.y * v.z + m.j.y * v.y + m.i.y * v.x + m.c.y;
	res.z = m.k.z * v.z + m.j.z * v.y + m.i.z * v.x + m.c.z;
	return res
end
----------------------------------------------------------------------------------------------------
-- выделение из матрицы углов поворота в последовательности x,z,y
-- подразумевается, что матрица является правильной матрицей поворота
-- функция содрана из библиотеки Wild Magic 5
function extract_euler_xzy(m)
	if m.i.y < 1 then
		if m.i.y > -1 then
			local az = math.asin(-m.i.y)
			local ax = math.atan2(m.k.y, m.j.y)
			local ay = math.atan2(m.i.z, m.i.x)
			return ax, az, ay
		else
			local az = math.pi / 2
			local ax = -math.atan2(-m.k.x, m.k.z)
			local ay = 0
			return ax, az, ay
		end
	else
		local az = -math.pi / 2
		local ax = math.atan2(-m.k.x, m.k.z)
		local ay = 0
		return ax, az, ay
	end
end

local base_box_vertices = {
	vector():set(-.5, -.5, -.5),
	vector():set(-.5, -.5,  .5),
	vector():set(-.5,  .5,  .5),
	vector():set(-.5,  .5, -.5),
	vector():set( .5,  .5,  .5),
	vector():set( .5,  .5, -.5),
	vector():set( .5, -.5,  .5),
	vector():set( .5, -.5, -.5),
}
function build_box_vertices(xformed_box_transformation)
	local vertices = {}
	for i,v in ipairs(base_box_vertices) do
		vertices[i] = transform_tiny(xformed_box_transformation, v)
	end
	return vertices
end

function build_plane(arg1, arg2, arg3)
	local d13 = vector():sub(arg3, arg1)
	local d12 = vector():sub(arg2, arg1)
	local plane = {}
	plane.n = vector():crossproduct(d13, d12):normalize() -- нормаль к плоскости
	plane.d = - arg1:dotproduct(plane.n) -- точка на плоскости, которая одновременно находится
	-- на нормали к этой плоскости, выходящей из начала координат (ближайшая к началу координат 
	-- точка плоскости)
	return plane
end

-- получение world-трансформации объекта
function get_xform(cobj)
	local xform = matrix()
	if type(cobj.get_go_float) == "function" then
		local a = {}
		for i=0,15 do
			a[i] = cobj:get_go_float(80 + i*4)
		end
		xform:set(
			vector():set(a[0], a[1], a[2]),
			vector():set(a[4], a[5], a[6]),
			vector():set(a[8], a[9], a[10]),
			vector():set(a[12], a[13], a[14])
		)
	else
		xform:set(
			vector():set(1, 0, 0),
			vector():set(0, 1, 0),
			vector():set(0, 0, 1),
			cobj:position()
		)
	end
	xform._14_ = 0
	xform._24_ = 0
	xform._34_ = 0
	xform._44_ = 1
	--print_matrix("xform", xform)
	--print_vector("pos", cobj:position())
	return xform
end

function decompose_matrix(m, offset, scale, rotation, shear)
	offset:set(
		vector():set(1,0,0), 
		vector():set(0,1,0), 
		vector():set(0,0,1), 
		m.c)
	offset._44_ = 1.0
	--
	local sx = m.i:magnitude()
	local sy = m.j:magnitude()
	local sz = m.k:magnitude()
	scale:set(
		vector():set(sx,0,0), 
		vector():set(0,sy,0), 
		vector():set(0,0,sz), 
		vector())
	scale._44_ = 1.0
	rotation:set(
		vector():set(m.i:div(sx)),
		vector():set(m.j:div(sy)),
		vector():set(m.k:div(sz)),
		vector())
	rotation._44_ = 1.0
	shear:set(matrix():identity())
end

function combine_transformations(transl, scale, rotation, shear)
	return mul_43(
		matrix(),
		transl,
		mul_43(
			matrix(),
			shear,
			mul_43(
				matrix(),
				rotation,
				scale)
		)
	)
end

function get_all_shapes_data( cobj )
	local data = {}
	
	data.sobj = alife():object(cobj:id())
	local row_data = netpk:get( data.sobj, net_packet.f_state )
	local shapes_row_data = row_data.shapes
	
	local xform_orig = get_xform( cobj )
	
	local xoffset = matrix()
	local xscale = matrix()
	local xrot = matrix()
	local xshear = matrix()
	
	decompose_matrix(xform_orig, xoffset, xscale, xrot, xshear)
	
	local xform_comp = combine_transformations(matrix():identity(), xscale, xrot, xshear)
	
	data.xform = xoffset
	
	data.game_vertex_id = row_data.game_vertex_id
	data.distance = row_data.distance
	data.level_vertex_id = row_data.level_vertex_id
	if row_data.dest_game_vertex_id then	-- for level changer
		data.dest_game_vertex_id = row_data.dest_game_vertex_id
	elseif row_data.max_power then			-- for anomaly zone
		data.max_power = row_data.max_power
	end
	
	data.shapes = {}
	for i = 1, #shapes_row_data do
		local shape = {}
		data.shapes[i] = shape
		local shp = shapes_row_data[i]
		if shp.shtype == 0 then
			shape.t = 0
			shape.offset = shp.center
			shape.r = shp.radius
		elseif shp.shtype == 1 then
			shape.t = 1
			local m = matrix():set(shp.box_matrix)
			shape.m = mul_43(matrix(), xform_comp, m)
			shape.v = build_box_vertices(mul_43(matrix(), data.xform, shape.m))
			shape.planes = {}
			shape.planes[1] = build_plane(shape.v[1],shape.v[4],shape.v[6])
			shape.planes[2] = build_plane(shape.v[2],shape.v[3],shape.v[4])
			shape.planes[3] = build_plane(shape.v[7],shape.v[6],shape.v[5])
			shape.planes[4] = build_plane(shape.v[5],shape.v[3],shape.v[2])
			shape.planes[5] = build_plane(shape.v[4],shape.v[3],shape.v[5])
			shape.planes[6] = build_plane(shape.v[2],shape.v[1],shape.v[7])
			
			local offset = matrix()
			local scale = matrix()
			local rotation = matrix()
			local shear = matrix()
			decompose_matrix(shape.m, offset, scale, rotation, shear)
			shape.a = {extract_euler_xzy(rotation)}
			shape.offset = {offset.c.x, offset.c.y, offset.c.z}
			shape.scale = {scale.i.x, scale.j.y, scale.k.z}
			shape.shear = {shear.i.y, shear.i.z, shear.j.z}
		else
			log("get_all_shapes_data: unknown shape type: %s", tostring(shp.shtype))
		end
	end
	return data
end

function distance_from_shape_boundary(pos, shape, point)
	if shape.t == 0 then
		return (shape.r - vector():sub(vector():add(pos, shape.offset), point):magnitude())
	elseif shape.t == 1 then
		local dist = math.huge
		for _,plane in ipairs(shape.planes) do
			-- плоскость задана нормалью и растоянием
			local a = plane.n:dotproduct(point) + plane.d
			if a < dist then
				dist = a
			end
		end
		return dist
	else
		abort('distance_from_shape_boundary: unknown shape type: %s', tostring(shape.t))
	end
end

function distance_from_zone_boundary(zone_data, point)
	local dist = -math.huge
	for i,shape in ipairs(zone_data.shapes) do
		local d = distance_from_shape_boundary(zone_data.xform.c, shape, point)
		if d > dist then
			dist = d
		end
	end
	return dist
end
------------ OGSE - -------------------------------------------------------------------------

function init()
	local pk = n_netpk()

	local clsid2type = {
		actor				= 'cse_alife_creature_actor',

		script_stalker		= 'se_stalker',

		bloodsucker_s		= 'se_monster',
		boar_s				= 'se_monster',
		burer_s				= 'se_monster',
		cat_s				= 'se_monster',
		chimera_s			= 'se_monster',
		controller_s		= 'se_monster',
		dog_s				= 'se_monster',
		flesh_s				= 'se_monster',
		fracture_s			= 'se_monster',
		gigant_s			= 'se_monster',
		poltergeist_s		= 'se_monster',
		pseudodog_s			= 'se_monster',
		psy_dog_phantom_s	= 'se_monster',
		psy_dog_s			= 'se_monster',
		snork_s				= 'se_monster',
		tushkano_s			= 'se_monster',
		zombie_s			= 'se_monster',

		script_trader		= 'se_trader',

		['crow']			= 'cse_alife_creature_abstract',

		script_heli			= 'se_heli',

		car_s 				= 'se_car',

		artefact 			= 'cse_alife_inventory_item',
		artefact_s 			= 'cse_alife_inventory_item',
		device_detector_simple = 'cse_alife_inventory_item',
		obj_antirad			= 'cse_alife_inventory_item',
		obj_attachable		= 'cse_alife_inventory_item',
		obj_bandage			= 'cse_alife_inventory_item',
		obj_bolt			= 'cse_alife_inventory_item',
		obj_bottle			= 'cse_alife_inventory_item',
		obj_explosive		= 'cse_alife_inventory_item',
		obj_food			= 'cse_alife_inventory_item',
		obj_medkit			= 'cse_alife_inventory_item',
		wpn_grenade_f1		= 'cse_alife_inventory_item',
		wpn_grenade_launcher = 'cse_alife_inventory_item',
		wpn_grenade_rgd5	= 'cse_alife_inventory_item',
		wpn_scope			= 'cse_alife_inventory_item',
		wpn_scope_s			= 'cse_alife_inventory_item',
		wpn_silencer		= 'cse_alife_inventory_item',

		device_pda			= 'cse_alife_item_pda',

		device_torch_s		= 'se_item_torch',

		obj_document		= 'cse_alife_item_document',

		equ_exo				= 'cse_alife_item_custom_outfit',
		equ_military		= 'cse_alife_item_custom_outfit',
		equ_scientific		= 'cse_alife_item_custom_outfit',
		equ_stalker			= 'cse_alife_item_custom_outfit',
		equ_stalker_s		= 'cse_alife_item_custom_outfit',

		wpn_ammo			= 'cse_alife_item_ammo',
		wpn_ammo_m209		= 'cse_alife_item_ammo',
		wpn_ammo_og7b		= 'cse_alife_item_ammo',
		wpn_ammo_vog25		= 'cse_alife_item_ammo',

		wpn_knife_s 		= 'cse_alife_item_weapon',

		wpn_binocular_s		= 'cse_alife_item_weapon_magazined',
		wpn_hpsa_s	 		= 'cse_alife_item_weapon_magazined',
		wpn_lr300_s 		= 'cse_alife_item_weapon_magazined',
		wpn_pm_s 			= 'cse_alife_item_weapon_magazined',
		wpn_rpg7_s 			= 'cse_alife_item_weapon_magazined',
		wpn_svd_s	 		= 'cse_alife_item_weapon_magazined',
		wpn_svu_s 			= 'cse_alife_item_weapon_magazined',
		wpn_usp45_s 		= 'cse_alife_item_weapon_magazined',
		wpn_val_s 			= 'cse_alife_item_weapon_magazined',
		wpn_vintorez_s 		= 'cse_alife_item_weapon_magazined',
		wpn_walther_s 		= 'cse_alife_item_weapon_magazined',

		wpn_bm16_s 			= 'cse_alife_item_weapon_shotgun',
		wpn_rg6_s 			= 'cse_alife_item_weapon_shotgun',
		wpn_shotgun_s 		= 'cse_alife_item_weapon_shotgun',

		wpn_ak74_s 			= 'cse_alife_item_weapon_magazined_w_gl',
		wpn_groza_s 		= 'cse_alife_item_weapon_magazined_w_gl',

		obj_breakable		= 'cse_alife_object_breakable',

		obj_phskeleton		= 'cse_alife_ph_skeleton_object',

		obj_physic			= 'cse_alife_object_physic',
		obj_phys_destroyable = 'cse_alife_object_physic',
		script_phys			= 'cse_alife_object_physic',	-- se_physic

		aem_lamp			= 'cse_alife_object_hanging_lamp',
		hanging_lamp		= 'cse_alife_object_hanging_lamp',

		inventory_box		= 'cse_alife_dynamic_object',
		projector			= 'cse_alife_dynamic_object',

		obj_climable		= 'cse_alife_object_climable',

		script_restr		= 'cse_alife_space_restrictor',

		zone_subway			= 'se_restrictor',

		level_changer		= 'cse_alife_level_changer',

		nogravity_zone		= "cse_alife_anomalous_zone",
		zone_radioactive	= "cse_alife_anomalous_zone",

		zone_buzz_s			= 'se_zone_anom',
		zone_electra_s		= 'se_zone_anom',
		zone_galant_s		= 'se_zone_anom',
		zone_ice_s			= 'se_zone_anom',
		zone_mbald_s		= 'se_zone_anom',
		zone_mincer_s		= 'se_zone_anom',
		zone_mosquito_bald_s = 'se_zone_anom',
		zone_zharka_s		= 'se_zone_anom',

		ameba_zone			= 'cse_alife_zone_visual',
		zone_rusty_hair		= 'cse_alife_zone_visual',

		zone_bfuzz_s		= 'se_zone_visual',

		torrid_zone			= 'cse_alife_torrid_zone',

		respawn				= 'se_respawn',

		smart_terrain		= 'se_smart_terrain'
	}
	for cls_id, cls in pairs(clsid2type) do
		if clsid[cls_id] and pk["r_st_"..cls] and pk["w_st_"..cls]
			and pk["r_upd_"..cls] and pk["w_upd_"..cls]
		then
			clsid2func[ clsid[cls_id] ] = cls
		--	log("%s = %s", cls_id, tostring(clsid[cls_id]))
		else
			abort("naxac_netpk.init: clsid [%s:%s:%s] can't added, read:[%s :: %s], write:[%s :: %s]",
				cls_id, tostring( clsid[cls_id] ), cls,
				type( pk["r_st_"..cls] ), type( pk["r_upd_"..cls] ),
				type( pk["w_st_"..cls] ), type( pk["w_upd_"..cls] ) )
		end
	end
	
	return pk
end

function get_str_clsid(cls)
	return clsid2func[cls] or "nil"
end
---------------------------------------------------------------------------------------------
function set_flag(obj_flags, flag_name, mode)
	local flag = object_flags[flag_name]
	if flag then
		local b = bit_and(obj_flags, flag) ~= 0
		if mode==false and b then
			return bit_and(obj_flags, bit_not(flag))
		elseif mode==true and not b then
			return bit_and(obj_flags, flag)
		else
			return obj_flags
		end
	else
		log("! naxac_netpk.set_flag: Unknown flag name '%s'", tostring(flag_name))
	end
	return obj_flags
end

function get_ammo_size( obj )
	local pk = net_packet()
	cse_alife_item_ammo.STATE_Write( obj, pk )
	pk:r_seek( pk:w_tell() - 2 )
	return pk:r_u16()	-- ammo_left
end

function get_ammo_type( obj )
	local pk = net_packet()
	cse_alife_item_weapon.STATE_Write( obj, pk )
	pk:r_seek( pk:w_tell() - 1 )
	return pk:r_u8()	-- ammo_type
end

function get_ammo_elapsed( obj )
	local pk = net_packet()
	cse_alife_item_weapon.STATE_Write( obj, pk )
	pk:r_seek( pk:w_tell() - 5 )
	return pk:r_u16()	-- ammo_elapsed
end

function get_character_name( se_npc )
	local pk = net_packet()
	local tmp = {}
	se_npc:STATE_Write ( pk )
	netpk:r_st_cse_alife_trader_abstract ( tmp, pk )
	return tmp.character_name
end
