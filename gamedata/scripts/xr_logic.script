-- -*- mode: lua; encoding: windows-1251 -*-
----------------------------------------------------------------------------------------------------
-- Script switching logic
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

--[[

----------------------------------------------------------------------------------------------------
-- ФУНКЦИИ, КОТОРЫЕ РАЗРЕШЕНО ВЫЗЫВАТЬ ИЗ ДРУГИХ СКРИПТОВ
----------------------------------------------------------------------------------------------------
  Активация схем производится с помощью функций:

function gulag_activate(npc, ini, section, gulag_name, death, combat, actor_dialogs, trade, hit)
Предназначение:
  активирует заданную схему, используется схемой гулаг. Тип скрипта определяется автоматически по имени секции.
Здесь:
  npc - персонаж, для которого будет активирована схема
  ini - его customdata
  section - имя секции, которая должна быть активирована
  gulag_name - имя гулага, которое будет добавлено спереди к именам путей
  death, combat, actor_dialogs, trade, hit - имена секций, задающих поведение при смерти и в бою

function assign_storage_and_bind(npc, ini, scheme, section)
Предназначение:
  Вызывает функцию add_to_binder схемы, а также создает (если его еще нет) и возвращает ссылку на storage
  для схемы. Примечание: в storage при этом могут оставаться старые данные, схема должна очистить его
  самостоятельно.

function subscribe_action_for_events(npc, storage, new_action)
Предназначение:
  Регистрирует класс для получения нотификаций о таких событиях как сброс схемы, сохранение и т.д.
  Класс реализует соответствующие функции (reset_scheme() и т.д.), которые будут вызываться из xr_logic
  в нужные моменты.

function pick_section_from_condlist(actor, npc, condlist)
Предназначение:
  Проверяет условия condlist, и если они успешны - ставит указанные infoportions и возвращает текст.
  Если условия не выполняются - возвращает nil.

function try_switch_to_another_section(npc, st, actor)
Предназчанение:
  Используя настройки xr_logic из storage персонажа, пытается переключить его на другую схему, если
  хоть одно из условий переключения сработало. Обычно вызывается из метода update класса персонажа.

function is_active(npc, st)
Предназначение:
  Вызывается из evaluator-а (или в самом начале update у предметов и монстров) для проверки, что данная
  схема сейчас активна (схема определяется по данным в storage).

function cfg_get_switch_conditions(ini, section, npc)
Предназначение:
  Считывает все возможные условия переключения схем.

function parse_condlist(npc, section, field, src)
Предназначение:
  Распарсивает условия вида: {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ... в таблицу.
  Параметры section и field используются только в сообщениях об ошибках. Если строка src считана не из файла,
  а передается в эту функцию гулагом, то нужно задать следующие параметры:
--]]
--    section = "[[[gulag_tasks.script]]]"
--    field = "[[[gulag_name=имя_гулага]]]"
--[[
----------------------------------------------------------------------------------------------------
-- ПРИВАТНЫЕ ФУНКЦИИ
----------------------------------------------------------------------------------------------------

function activate_by_section(npc, ini, section, loading)
Предназначение:
  Активирует указанную секцию. Если в данный момент какая-либо секция уже активирована, сообщает об ошибке.

function switch_to_section(npc, st, section)
Предназначение:
  Выполняет переключение с одной секции на другую, если новая секция не nil. Если же она nil, остается
  активной старая секция.

function abort_syntax_error_in_cond(npc, section, field)
Предназначение:
  Сообщает о синтаксической ошибке в условиях переключения схем секции section и поля field, и останавливает
  игру.

function parse_infop(rslt, str)
Предназначение:
  Распарсивает условия вида " +infop1 =func -infop2 " и т.д. (все не перечислены) в таблицу.

function cfg_get_number_and_condlist(ini, section, field, npc)
function cfg_get_string_and_condlist(ini, section, field, npc)
function cfg_get_condlist(ini, section, field, npc)
Предназначение:
  Считывает из customdata различные условия переключения схем.

function add_condition(lst, at, cond)
Предназначение:
  Добавляет условие в список условий переключения схем.

function cfg_get_overrides(ini, section, npc)
Предназначение:
  Считывает настройки для схем общего поведения.

function generic_scheme_overrides(npc)
Предназначение:
  Возвращает ссылку на настройки схем общего поведения, актуальные для работающей в данный момент схемы,
  либо nil, если ни одна из секций не активна, либо настройки не заданы.

--]]

--[[
-- Предназначение:
--      вызывается при включении набора скриптов через секцию logic у персонажа. Если в секции logic присутствует только
--      поле cfg, использует конфигурационный файл, заданный в этом поле, и возвращает новый ini file.
-- Здесь:
--  npc - персонаж, для которого будет активирована схема
--  ini - его customdata
--  stype - тип скрипта. Поскольку имя секции все еще неизвестно, его нужно задавать явно. Допустимые значения
--          перечислены в файле modules.script.
--  section - имя секции logic
--  gulag_name - имя гулага, если скрипт включается гулагом, а не биндером
--]]
local tabl_netpda_varnames={
-- Strelok
["s_teleport0_1"] = true,
["s_teleport1_2"] = true,
["s_teleport3_2"] = true,
["s_teleport4_1"] = true,
-- kostya
["t_teleport1_1"] = true,
-- Коллектор
["val_teleport_1"] = true,
-- TM
["tm_teleport_1"] = true,
["tm_teleport_2"] = true,
["tm_teleport_2_1"] = true,
["tm_teleport_2_2"] = true,
["tm_teleport_3"] = true,
["tm_teleport_4"] = true,
-- Острова
["fli36_tp1"] = true,
["fli29_tp1"] = true,
["fli37_tp1"] = true,
["fli35_tp1"] = true,
["fli9_tp1"] = true,
["fli1_tp1"] = true,

["m_teleport_6"] = true,
["m_teleport_26"] = true,
["m_teleport_35"] = true,
["m_teleport_36"] = true,
["m_teleport_37"] = true,
["m_teleport_38"] = true,
["m_teleport_39"] = true,
["m_teleport_40"] = true,
["m_teleport_41"] = true,
["m_teleport_42"] = true,
["m_teleport_43"] = true,
["m_teleport_44"] = true,
["m_teleport_45"] = true,
["m_teleport_46"] = true,
["m_teleport_47"] = true,
["m_teleport_48"] = true,
["m_teleport_49"] = true,
["m_teleport_50"] = true,
["m_teleport_51"] = true,
["m_teleport_52"] = true,
["m_teleport_53"] = true,
["m_teleport_54"] = true,
--["gps_labels"] = true,
["lim_zone_teleport1"] = true,
["lim_zone_teleport2"] = true,
["zone_teleport_new"] = true,
["zone_teleport_new_out"] = true,
["flame_start"] = true,
["flame_reload"] = true,
["flame_reload_count"] = true,
["sak_teleport"] = true,
["glushitel_reload"] = true,
["af_var"] = true
}
function configure_schemes(npc, ini, ini_filename, stype, section_logic, gulag_name)
  --printf("DEBUG: enable_scripts: npc:name()=%s", npc:name())

  local npc_id = npc:id()
  local st     = db.storage[npc_id]

  -- если какая-то схема была до этого активна, деактивировать её
  if st.active_section then
    issue_event(npc, st[st.active_scheme], "deactivate", npc)
  end

  local actual_ini
  local actual_ini_filename
  if not ini:section_exist(section_logic) then
    if not gulag_name then
      -- Общие схемы должны работать и без logic:
      actual_ini_filename = ini_filename
      actual_ini = ini -- персонаж не обязательно должен иметь секцию logic
    else
      -- Иначе это персонаж Gulag-а и ему не задали работу:
      abort("[xr_logic.configure_schemes] ERROR: object '%s': unable to find section '%s'", npc:name(), section_logic)
    end
  else
    local filename = utils.cfg_get_string(ini, section_logic, "cfg", npc, false, "")
    if filename then
      printf("_bp: enable_scripts: object '%s' has external configuration file '%s'", npc:name(), filename)
      -- Рекурсивно обработать конфигурационный файл, на который ссылается поле cfg
      actual_ini_filename = filename
      actual_ini = ini_file(filename)
      return configure_schemes(npc, actual_ini, actual_ini_filename, stype, section_logic, gulag_name)
      --[[
      if actual_ini:line_count(section_logic) == 0 then
        abort("file '%s' does not exist or is empty, or has no section '%s'",
          filename, section_logic)
      end
      --]]
    else
      printf("_bp: enable_scripts: object '%s' has NO external configuration file, using '%s'", npc:name(), ini_filename)
      actual_ini_filename = ini_filename
      actual_ini = ini
    end
  end

  -- Поскольку в момент активации схемы могли работать ранее установленные общие схемы, нужно их все отключить:
  disable_generic_schemes(npc, stype)
  -- Включаем все общие схемы (раненный, коллбек на попадание и т.д.):
  enable_generic_schemes(actual_ini, npc, stype, section_logic)

  -- Инициализация торговли
  if IsHuman[npc:clsid()] then
    local trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_generic.ltx")
    local rx_st = rx_ai.get_storage(npc:id())
	rx_st.is_trader = actual_ini:line_exist(section_logic, "trade")
	trade_manager.trade_init(npc, trade_ini)
  end

  st.active_section = nil
  st.active_scheme = nil
  if gulag_name then
    st.gulag_name = gulag_name
  else
    st.gulag_name = ""
  end
  st.stype = stype
  st.ini = actual_ini
  st.ini_filename = actual_ini_filename
  st.section_logic = section_logic

  return st.ini
end

-- Вызывается биндером с целью определить первую активную схему
function determine_section_to_activate(npc, ini, section_logic, actor)
  if not ini:section_exist(section_logic) then
    return "nil"
  end

  -- Распарсить строку выбора активной секции с учетом команд, заключенных в %%
  local active_section_cond = cfg_get_condlist(ini, section_logic, "active", npc)
  local active_section
  if not active_section_cond then
    abort("[xr_logic.determine_section_to_activate] object '%s': section '%s': unable to find field 'active'", npc:name(), section_logic)
  else
    active_section = pick_section_from_condlist(actor, npc, active_section_cond.condlist)
    if not active_section then
      abort("[xr_logic.determine_section_to_activate] object '%s': section '%s': section 'active' has no conditionless else clause",
        npc:name(), section_logic)
    end
  end
  if active_section and db.storage[npc:id()].stype
	and db.storage[npc:id()].stype<=1
--	and db.storage[npc:id()].stype~=stypes[utils.get_scheme_by_section(active_section)]
	and db.storage[npc:id()].stype~=stypes[string.match( active_section, "^[_%a]+" )]
  then
  -- Блокируем активацию схемы для зверушек в человеческих гулагах. Dirty Hack.
    return "nil"
  else
  return active_section
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В enable_generic_schemes
------------------------------------------------------------------------------------------------------------
function disable_generic_schemes(npc, stype)
  if stype == modules.stype_stalker then
    xr_combat.disable_scheme(npc, "combat")
    if xrs_ai then xrs_ai.disable_schemes(npc, stype) end
    if rx_ai then rx_ai.disable_schemes(npc, stype) end
    xr_use.disable_scheme(npc, "use")
    xr_hit.disable_scheme(npc, "hit")
    xr_meet.disable_scheme(npc, "actor_dialogs")
    xr_heli_hunter.disable_scheme(npc, "heli_hunter")
    xr_combat_ignore.disable_scheme(npc, "combat_ignore")
  elseif stype == modules.stype_mobile then
    mob_combat.disable_scheme(npc, "mob_combat")
    mob_trade.disable_scheme(npc, "mob_trade")
  elseif stype == modules.stype_item then
    ph_on_hit.disable_scheme(npc, "ph_on_hit")
  elseif stype == modules.stype_heli then
    xr_hit.disable_scheme(npc, "hit")
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В disable_generic_schemes
------------------------------------------------------------------------------------------------------------
function enable_generic_schemes(ini, npc, stype, section)
  if stype == modules.stype_stalker then

    if blowout_scheme then blowout_scheme.set_hide(npc,ini,"blowout_scheme",section) end

    --xr_reactions.set_reactions(npc, ini, "reactions", section)
    xr_danger.set_danger(npc, ini, "danger", "danger")

    local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
    xr_combat.set_combat_checker(npc, ini, "combat", combat_section)

    local use_section = utils.cfg_get_string(ini, section, "on_use", npc, false, "")
    if use_section then
      xr_use.set_use_checker(npc, ini, "use", use_section)
    end
    local info_section = utils.cfg_get_string(ini, section, "info", npc, false, "")
    if info_section then
      stalker_generic.set_npc_info(npc, ini, "info", info_section)
    end

    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end

    local actor_dialogs_section = utils.cfg_get_string (ini, section, "actor_dialogs", npc, false, "")
    if actor_dialogs_section then
      xr_meet.set_actor_dialogs(npc, ini, "actor_dialogs", actor_dialogs_section)
    end

    local wounded_section = utils.cfg_get_string (ini, section, "wounded", npc, false, "")
    xr_wounded.set_wounded (npc, ini, "wounded", wounded_section)

    xr_abuse.set_abuse(npc, ini, "abuse", section)

    local meet_section = utils.cfg_get_string (ini, section, "meet", npc, false, "")
    xr_meet.set_meet (npc, ini, "meet", meet_section)

    local death_section = utils.cfg_get_string (ini, section, "on_death", npc, false, "")
    xr_death.set_death (npc, ini, "death", death_section)

    local heli_hunter_section = utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
    xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", heli_hunter_section)

    local combat_ignore_section = utils.cfg_get_string(ini, section, "combat_ignore", npc, false, "")
    if combat_ignore_section then
      printf("combat_ignore_section= '%s'", combat_ignore_section )
      xr_combat_ignore.set_combat_ignore_checker(npc, ini, "combat_ignore", combat_ignore_section)
    end

    if watcher_act then
      watcher_act.set_scheme(npc,ini,"watcher_act","watcher_act")
    end

  if xrs_ai then xrs_ai.enable_schemes(ini, npc, stype, section) end
  if rx_ai then rx_ai.enable_schemes(ini,npc) end
  elseif stype == modules.stype_mobile then
    local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
    if combat_section then
      mob_combat.set_scheme(npc, ini, "mob_combat", combat_section)
    end

    local death_section = utils.cfg_get_string(ini, section, "on_death", npc, false, "")
    mob_death.set_scheme(npc, ini, "mob_death", death_section)

    local trade_section = utils.cfg_get_string(ini, section, "on_trade", npc, false, "")
    if trade_section then
      mob_trade.set_scheme(npc, ini, "mob_trade", trade_section)
    end

    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end

    mob_panic.set_scheme(npc, ini, "mob_panic")

  elseif stype == modules.stype_item then
    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    printf("HIT SECTION [%s]", tostring(hit_section))
    if hit_section then
      ph_on_hit.set_scheme(npc, ini, "ph_on_hit", hit_section)
    end

  elseif stype == modules.stype_heli then
    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end
  end
end

function activate_by_section(npc, ini, section, loading)
	printf("DEBUG: object '%s': activate_by_section: looking for section '%s'", npc:name(), section)

	if loading == nil then
		abort("[xr_logic.activate_by_section] : loading field is nil, true or false expected")
	end

	local st = db.storage[npc:id()]
	if st.active_section then
		abort("[xr_logic.activate_by_section] : while processing section '%s': character '%s': trying to " ..
			"activate more than one schemes at once (section '%s' is active)",
			section, npc:name(), st.active_section)
	end

	if not loading then
		st.activation_time = time_global()
		-- GAMETIME added by Stohe.
		st.activation_game_time = game.get_game_time()
	end

	if section == "nil"
		or section == "sr_idle@nil"
	then
		st.overrides = nil
		reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
		st.active_section = nil
		st.active_scheme = nil
--'		st.pstor = nil
		return
	end

	if section and ini:section_exist(section) then
	--	local scheme = utils.get_scheme_by_section(section)
		local scheme = string.match( section, "^[_%a]+" )
		if scheme == nil then
			abort("[xr_logic.activate_by_section] object '%s': unable to determine scheme name from section name '%s'",
				npc:name(), section)
		end

		-- Загрузить оверрайды:
		st.overrides = cfg_get_overrides(ini, section, npc)

		-- Сбросить общие схемы:
		reset_generic_schemes_on_scheme_switch(npc, scheme, section)

		-- schemes[scheme] даст имя файла (модуля), в котором реализована схема
		-- _G[] даст указатель на неймспейс (таблицу) этого модуля
		local mdl = _G[ schemes[scheme] ]
			or abort( "[xr_logic.activate_by_section] invalid module[script]: [%s] (%s)", scheme, npc:name() )
		
		mdl.set_scheme(npc, ini, scheme, section, st["gulag_name"])
		--printf("DEBUG: activate_by_section: scheme '%s' activated from section '%s'", scheme, section)
		st.active_section = section
		st.active_scheme = scheme

		if st.stype == modules.stype_stalker then
			-- чтобы избежать дальнейшего движения по пути при установке рестрикторов
			utils.send_to_nearest_accessible_vertex(npc, npc:level_vertex_id())
			issue_event(npc, st[scheme], "activate_scheme", loading, npc)
		else
			issue_event(npc, st[scheme], "reset_scheme", loading, npc)
		end
	else
		abort("[xr_logic.activate_by_section] object '%s': activate_by_section: section '%s' does not exist", npc:name(), section)
	end
end

--[[
-- Предназначение:
--  Производит сброс состояния объекта (снимает коллбеки, отключает разговор) непосредственно перед включением
--  новой схемы.
--]]
function reset_generic_schemes_on_scheme_switch(npc, scheme, section)
  printf("_bp: reset_generic_schemes_on_scheme_switch: npc:name()='%s'", npc:name())
  local st = db.storage[npc:id()]

  if not st.stype then
    return
  end

  if st.stype == modules.stype_stalker then
    --xr_reactions.reset_reactions(npc, scheme, st, section)
    xr_meet.dialog_manager_reset(npc, st.stype)
    xr_meet.reset_meet(npc, scheme, st, section)
    xr_abuse.reset_abuse(npc, scheme, st, section)
    xr_wounded.reset_wounded(npc, scheme, st, section)
    xr_death.reset_death(npc, scheme, st, section)
    xr_danger.reset_danger(npc, scheme, st, section)
    stalker_generic.reset_threshold(npc, scheme, st, section)
    stalker_generic.reset_show_spot(npc, scheme, st, section)
	if rx_ai then rx_ai.reset_schemes(npc, scheme, st, section) end
  elseif st.stype == modules.stype_mobile then
    --printf("_bp: disabling talk")
    --npc:disable_talk() -- теперь делается в dialog_manager_reset
    xr_meet.dialog_manager_reset(npc, st.stype)
    mob_release(npc)
    if npc:clsid() == clsid.bloodsucker_s then
      if scheme == "nil" then
        npc:set_manual_invisibility(false)
      else
        npc:set_manual_invisibility(true)
        -- Видимый или нет определяет схема, которая возьмет его под контроль:
        --npc:set_invisible(false)
      end
    end

    mob_panic.reset_panic(npc, scheme, st, section)

  elseif st.stype == modules.stype_item then
    npc:set_callback(callback.use_object, nil)
    npc:set_nonscript_usable(true)
    if npc:clsid() == clsid.car then
      -- Другие объекты под скрипт не берутся, поэтому для них не надо сбрасывать
      npc:destroy_car()
      mob_release(npc)
    end
  end
end

function assign_storage_and_bind(npc, ini, scheme, section)
  local npc_id = npc:id()
  local st = db.storage[npc_id][scheme]

  if not st then
    st = {}
    db.storage[npc_id][scheme] = st

    st["npc"] = npc

    -- Схема стартует впервые - прибиндить
    --printf("DEBUG: assign_storage_and_bind: bind scheme: '%s'", scheme)
    _G[schemes[scheme]].add_to_binder(npc, ini, scheme, section, st)
  end

  st["scheme"] = scheme
  st["section"] = section
  st["ini"] = ini

  return st
end

function subscribe_action_for_events(npc, storage, new_action)
  --printf("DEBUG: registering new action for reset event (npc:name() = '%s')", npc:name())

  if not storage.actions then
    storage.actions = {}
  end

  storage.actions[new_action] = true
end

function unsubscribe_action_from_events(npc, storage, new_action)
  if not storage.actions then
    storage.actions = {}
  end

  storage.actions[new_action] = nil
end

-- st - storage активной схемы
function issue_event(npc, st, event_fn, ...)
  if not st or not st.actions then
    return
  end

  local activation_count = 0
  local action_ptr, is_active = 0, 0

  for action_ptr, is_active in pairs(st.actions) do
    if is_active and action_ptr[event_fn] then
      action_ptr[event_fn](action_ptr, ...)
      activation_count = activation_count + 1
    end
  end

--  if activation_count == 0 and
--    event_fn == "activate_scheme"
--  then
--    abort("xr_logic: issue_event: activate_scheme handler not found, active_scheme is '%s'", db.storage[npc:id()].active_scheme)
--  end
end

function pick_section_from_condlist(actor, npc, condlist)
	local rval = nil -- math.random(100)
	--printf("_bp: pick_section_from_condlist: rval = %d", rval)

	local infop_conditions_met
	for n, cond in pairs(condlist) do
		infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены
		for inum, infop in pairs(cond.infop_check) do
			if infop.prob then
				if not rval then
					rval = math.random(100)
				end
				if infop.prob < rval then
					infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
					break
				end
			elseif infop.func then
				local func=nil
				local module,fname=string.match(infop.func,"(.+)[.](.+)")
				if not fname then
					func=xr_conditions[infop.func]
				else
					if _G[module] and _G[module][fname] then
						func=_G[module][fname]
					end
				end
				--printf("_bp: infop.func = %s", infop.func)
				if not func then
					abort("[xr_logic.pick_section_from_condlist] object '%s': function '%s' is " ..
						"not defined in xr_conditions.script", (npc and npc:name() or "<nil>"), infop.func)
				end

				if func(actor, npc, infop.params) then
					if not infop.expected then
						infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
						break
					end
				else
					if infop.expected then
						infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
						break
					end
				end
			elseif has_alife_info(infop.name) then
				if not infop.required then
					--'printf("FAILED: actor has infop '%s', which is NOT needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
					infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
					break
				else
					--'printf("PASSED: actor has infop '%s', which is needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
				end
			else
				if infop.required then
					--'printf("FAILED: actor has NO infop '%s', which is needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
					infop_conditions_met = false -- инфопоршена нет, но он нужен
					break
				else
					--'printf("PASSED: actor has NO infop '%s', which is not needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
				end
			end
		end
		--printf("_bp: infop_cond_met = %s", utils.to_str(infop_conditions_met))
		if infop_conditions_met then
			-- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
			-- infoportions:
			for inum, infop in pairs(cond.infop_set) do
				if infop.func then
					local func=nil
					local module,fname=string.match(infop.func,"(.+)[.](.+)")
					if not fname then
						func=xr_effects[infop.func]
					else
						if _G[module] and _G[module][fname] then
							func=_G[module][fname]
						end
					end
					if not func then
						abort("[xr_logic.pick_section_from_condlist] object '%s': function '%s' is " ..
							"not defined in xr_effects.script", (npc and npc:name() or "<nil>"), infop.func)
					end
					func(actor, npc, infop.params)

				elseif infop.required then
					if not has_alife_info(infop.name) then
						actor:give_info_portion(infop.name)
					end
				else
					if has_alife_info(infop.name) then
						actor:disable_info_portion(infop.name)
					end
				end
			end
			if cond.section == "never" then
				return nil
			else
				return cond.section
			end
		end
	end

	--printf("_bp: pick_section_from_condlist: nil")
	return nil
end

-- Выполняет переключение на указанную секцию, если задана.
-- Если section == nil, остается работать старая секция.
function switch_to_section(npc, st, section)
	if section == nil or section == "" then return false end
	
	local npc_st = db.storage[npc:id()]
	local active_section = npc_st.active_section
	if active_section == section then return false end

	-- call scheme::finalize()
	if active_section then
		issue_event(npc, npc_st[npc_st.active_scheme], "deactivate", npc)
	end

	npc_st.active_section = nil
	npc_st.active_scheme = nil
	activate_by_section(npc, st.ini, section, false)
	return true
end

function see_actor(npc)
  return npc:alive() and npc:see(db.actor)
end

function cond_name(cond, etalon)
  return string.find( cond, "^"..etalon.."%d*$" ) ~= nil
end

function try_switch_to_another_section(npc, st, actor)
    if not actor then
        abort("[xr_logic.try_switch_to_another_section]: error in implementation of scheme '%s': actor is nil", st.scheme)
    end
    
    local l = st.logic

    if not l then
        abort("[xr_logic.try_switch_to_another_section] Can't find script switching information in storage, scheme '%s'", st.scheme or "<nil>")
    end

    local npc_id = npc:id()
    local switched = false
	local name
    for _, c in pairs(l) do
        name = string.match(c.name, '^[%a_]+')
        
        if name == "on_actor_dist_le" then
            switched = see_actor(npc) and distance_between(actor, npc) <= c.v1
        elseif name == "on_actor_dist_le_nvis" then
            switched = distance_between(actor, npc) <= c.v1
        elseif name == "on_actor_dist_ge" then
            switched = see_actor(npc) and distance_between(actor, npc) > c.v1
        elseif name == "on_actor_dist_ge_nvis" then
            switched = distance_between(actor, npc) > c.v1
        elseif name == "on_signal" then
            switched = st.signals and st.signals[c.v1]
        elseif name == "on_info" then
            switched = true
        elseif name == "on_timer" then
            switched = time_global() >= db.storage[npc_id].activation_time + c.v1
        elseif name == "on_game_timer" then
            switched = game.get_game_time():diffSec(db.storage[npc_id].activation_game_time) >= c.v1
        elseif name == "on_actor_in_zone" then
            switched = utils.npc_in_zone(actor, db.zone_by_name[c.v1])
        elseif name == "on_actor_not_in_zone" then
            switched = not utils.npc_in_zone(actor, db.zone_by_name[c.v1])
        elseif name == "on_npc_in_zone" then
            switched = utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
        elseif name == "on_npc_not_in_zone" then
            switched = not utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
        elseif name == "on_actor_inside" then
            switched = utils.npc_in_zone(actor, npc)
        elseif name == "on_actor_outside" then
            switched = not utils.npc_in_zone(actor, npc)
        else
            abort("[xr_logic.try_switch_to_another_section]: invalid condition: [%s] (%s)", c.name, npc:name())
        end

		if switched
			and switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
		then
			return true
		end
    end
    
    return false
end

function is_active(npc, st)
  if st.section == nil then
    abort("[xr_logic.is_active] npc '%s': st.section is nil, active section is '%s'",
      npc:name(), utils.to_str(db.storage[npc:id()].active_section))
  end
  local is_act = (st.section == db.storage[npc:id()].active_section)

  -- Текущая секция активна и не сработало ни одно из условий переключения на другие секции
  return is_act
end


function abort_syntax_error_in_cond(npc, section, field)
  abort("[xr_logic.abort_syntax_error_in_cond] object '%s': section '%s': field '%s': syntax error in switch condition",
    (npc and npc:name() or "<nil>"), section or "<nil>", field or "<nil>")
end

-- На входе имеем пустой массив и строку вида "  +infop1  -infop2 +infop3 ... "
-- Заполнить массив:
-- { "infop_name" = true/false }.
function parse_infop1(rslt, str)
  --printf("_bp: parse_infop: %s", utils.to_str(str))
  if str then
    local infop_name, sign
    local infop_n = 1
    for s in string.gfind(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
      --printf("_bp: parse_infop: s=%s", utils.to_str(s))
      sign = string.sub(s, 1, 1)
      infop_name = string.sub(s, 2)
      if sign == "+" then
        rslt[infop_n] = { name = infop_name, required = true }
      elseif sign == "-" then
        rslt[infop_n] = { name = infop_name, required = false }
      elseif sign == "~" then
        rslt[infop_n] = { prob = tonumber(infop_name) }
      elseif sign == "=" then
        rslt[infop_n] = { func = infop_name, expected = true }
      elseif sign == "!" then
        rslt[infop_n] = { func = infop_name, expected = false }
      else
        abort("[xr_logic.parse_infop1] wrong condlist %s", str)
      end
      infop_n = infop_n + 1
    end
  end
end

function parse_func_params(str)
  local lst = {}
  local n
  for par in string.gfind(str, "%s*([^:]+)%s*") do
    n = tonumber(par)
    if n then table.insert(lst, n)
    else table.insert(lst, par) end
  end
  return lst
end

function parse_infop(rslt, str)
  --printf("_bp: parse_infop1: %s", utils.to_str(str))
  if str then
    local infop_name, sign
    local infop_n = 1
    local at, params
    for s in string.gfind(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
      --printf("_bp: parse_infop: s=%s", utils.to_str(s))
      sign = string.sub(s, 1, 1)
      infop_name = string.sub(s, 2)
      params = nil

      -- парсим параметры функций
      at = string.find(infop_name, "%(")
      if at then
        if string.sub(infop_name, -1) ~= ")" then
          abort("[xr_logic.parse_infop] wrong condlist %s", str)
        end
        if at < string.len(infop_name) - 1 then
          params = parse_func_params(string.sub(infop_name, at + 1, -2))
        else
          params = {}
        end
        infop_name = string.sub(infop_name, 1, at - 1)
      end

      if sign == "+" then
        rslt[infop_n] = { name = infop_name, required = true }
      elseif sign == "-" then
        rslt[infop_n] = { name = infop_name, required = false }
      elseif sign == "~" then
        rslt[infop_n] = { prob = tonumber(infop_name) }
      elseif sign == "=" then
        --printf("_bp: n = %s; r = %s", infop_name, utils.to_str(params))
        rslt[infop_n] = { func = infop_name, expected = true, params = params }
      elseif sign == "!" then
        --printf("_bp: n = %s; r = %s", infop_name, utils.to_str(params))
        rslt[infop_n] = { func = infop_name, expected = false, params = params }
      else
        abort("[xr_logic.parse_infop] wrong condlist %s", str)
      end
      infop_n = infop_n + 1
    end
  end
end

-- Распарсивает строку src вида:
-- {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ...
-- в таблицу:
-- {
--   1 = { infop_check = { 1 = {"infop1" = true} }, infop_set = { 1 = {"infop2" = false } }, section = "section1" },
--   2 = { infop_check = { 1 = {"infop3" = true}, 2 = {"infop4" = false} }, infop_set = {}, section = "section2" },
-- }
function parse_condlist(npc, section, field, src)
  local lst = {}

  -- 1) Разбиваем на разделенные запятыми части:
  local at, to, infop_check_lst, remainings, infop_set_lst, newsect

  --printf("_bp: src = %s", src)

  local n = 1
  for fld in string.gfind(src, "%s*([^,]+)%s*") do
    -- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
    lst[n] = {}
    --printf("_bp: iter %d: fld = %s", n, fld)

    -- Выделяем список infoportions для проверки:
    at, to, infop_check_lst = string.find(fld, "{%s*(.*)%s*}")
    if infop_check_lst then
      --printf("_bp: infop_check_lst: [%s]", infop_check_lst)

      -- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
      remainings = string.sub(fld, 1, at - 1) .. string.sub(fld, to + 1)
    else
      -- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
      remainings = fld
    end
    --printf("_bp: remainings: %s", remainings)

    -- Выделяем список infoportions для установки из remainings:
    at, to, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
    if infop_set_lst then
      -- Выделяем оставшуюся часть поля, т.е. имя секции:
      newsect = string.sub(remainings, 1, at - 1) .. string.sub(remainings, to + 1)
    else
      -- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
      newsect = remainings
    end
    --printf("_bp: newsect: %s", newsect)

    -- И сразу trim имя секции:
    at, to, newsect = string.find(newsect, "%s*(.*)%s*")
    if not newsect then
      abort_syntax_error_in_cond(npc, section, field)
    end

    -- Имя секции теперь можно сохранить:
    lst[n].section = newsect

    -- Теперь нужно распарсить infoportions в строке infop_check_lst и
    -- заполнить массив infop_check: { "infop_name" = true/false }.
    -- На входе имеем строку вида "  +infop1  -infop2 +infop3 ... "
    lst[n].infop_check = {}
    parse_infop(lst[n].infop_check, infop_check_lst)

    -- То же самое для устанавливаемых infoportions:
    lst[n].infop_set = {}
    parse_infop(lst[n].infop_set, infop_set_lst)

    n = n + 1
  end

  return lst
end

function cfg_get_number_and_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] or not par[2] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.v1 = tonumber(par[1])
  t.condlist = parse_condlist(npc, section, field, par[2])

  return t
end

function cfg_get_string_and_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] or not par[2] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.v1 = par[1]
  t.condlist = parse_condlist(npc, section, field, par[2])

  return t
end

function cfg_get_two_strings_and_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] or not par[2] or not par[3] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.v1 = par[1]
  t.v2 = par[2]
  t.condlist = parse_condlist(npc, section, field, par[3])

  return t
end

function cfg_get_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.condlist = parse_condlist(npc, section, field, par[1])

  return t
end

function add_condition(lst, at, cond)
  if cond then
    lst[at] = cond
    return at + 1
  end
  return at
end


function cfg_get_switch_conditions(ini, section, npc)
  local l = {}
  local t
  local n = 1

  local function add_conditions(func, cond)
    local i = 1
    local c = func(ini, section, cond, npc)

    while c ~= nil do
      n = add_condition(l, n, c, npc)

      i = i + 1

      c = func(ini, section, cond..i, npc)
    end
  end

  add_conditions( cfg_get_number_and_condlist, "on_actor_dist_le"      )
  add_conditions( cfg_get_number_and_condlist, "on_actor_dist_le_nvis" )
  add_conditions( cfg_get_number_and_condlist, "on_actor_dist_ge"      )
  add_conditions( cfg_get_number_and_condlist, "on_actor_dist_ge_nvis" )
  add_conditions( cfg_get_string_and_condlist, "on_signal"             )
  add_conditions( cfg_get_condlist           , "on_info"               )
  add_conditions( cfg_get_number_and_condlist, "on_timer"              )
  add_conditions( cfg_get_number_and_condlist, "on_game_timer"         )
  add_conditions( cfg_get_string_and_condlist, "on_actor_in_zone"      )
  add_conditions( cfg_get_string_and_condlist, "on_actor_not_in_zone"  )
  add_conditions( cfg_get_condlist           , "on_actor_inside"       )
  add_conditions( cfg_get_condlist           , "on_actor_outside"      )
  add_conditions( cfg_get_npc_and_zone       , "on_npc_in_zone"        )
  add_conditions( cfg_get_npc_and_zone       , "on_npc_not_in_zone"    )

  return l
end

function cfg_get_overrides(ini, section, npc)
  local l = {}

--  l.meet_enabled      = utils.cfg_get_bool(ini, section, "meet_enabled", npc, false)
--  l.meet_talk_enabled = utils.cfg_get_bool(ini, section, "meet_talk_enabled", npc, false)
--  l.meet_dialog       = utils.cfg_get_string(ini, section, "meet_dialog", npc, false, "")
--  l.meet_state        = utils.cfg_get_string(ini, section, "meet_state", npc, false, "")
--  l.reactions         = parse_names(utils.cfg_get_string(ini, section, "reactions", npc, false, "", ""))

  local tmp     = utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
  if tmp then
    l.heli_hunter = xr_logic.parse_condlist(npc, section, "heli_hunter", tmp)
  end

--  l.wounded_enabled   = utils.cfg_get_bool(ini, section, "wounded_enabled", npc, false)
  l.combat_ignore     = cfg_get_condlist(ini, section, "combat_ignore_cond", npc)
  l.combat_ignore_keep_when_attacked = utils.cfg_get_bool(ini, section, "combat_ignore_keep_when_attacked", npc, false)
  l.combat_type       = cfg_get_condlist(ini, section, "combat_type", npc)
  l.on_combat         = cfg_get_condlist(ini, section, "on_combat", npc)
  l.companion_enabled = utils.cfg_get_bool(ini, section, "companion_enabled", npc, false)

  if string.find(section, "kamp") ~= nil then
    l.soundgroup    = utils.cfg_get_string(ini, section, "center_point", npc, false, "")
  else
    l.soundgroup    = utils.cfg_get_string(ini, section, "soundgroup", npc, false, "")
  end


  return l
end

function cfg_get_npc_and_zone(ini, section, field, npc)
  local t = cfg_get_two_strings_and_condlist(ini, section, field, npc)

  if t then
    if AI then
      local se_obj = AI:story_object(tonumber(t.v1))
      if se_obj then
        t.npc_id = se_obj.id
      else
        t.npc_id = -1
        --abort("object '%s': section '%s': field '%s': there is no object with story_id '%s'", npc:name(), section, field, t.v1)
      end
    else
      t.npc_id = -1
      printf("WARNING: object '%s': section '%s': field '%s': can't use story_id without simulation!",
              npc:name(), section, field)
    end
  end

  return t
end

-- Возвращает ссылку на оверрайды, зарегистрированные в активной на данный момент секции,
-- либо nil, если ни одна из секций не активна, или оверрайдов нет.
function generic_scheme_overrides(npc)
  return db.storage[npc:id()].overrides
end

function mob_release(mob)
  if mob:get_script() then
    mob:script(false, script_name())
  end
end

function mob_capture(mob, reset_actions)
  if reset_actions == nil then
    abort("[xr_logic.mob_capture]: reset_actions parameter's value is not specified")
  end

  if reset_actions then
    reset_action(mob, script_name())
  else
    if not mob:get_script() then
      mob:script(true, script_name())
    end
  end
end

function mob_captured(mob)
  return mob:get_script()
end

function save_logic(obj, packet)
  local st = db.storage[obj:id()]

  packet:w_s32( (st.activation_time or 0) - time_global() )

  -- GAMETIME added by Stohe.
  utils.w_CTime(packet, st.activation_game_time)
end

function load_logic(obj, reader)
  local st = db.storage[obj:id()]

  st.activation_time = reader:r_s32() + time_global()

  -- GAMETIME added by Stohe.
  st.activation_game_time = utils.r_CTime(reader)
end

local pstor_number = 0
local pstor_string = 1
local pstor_boolean = 2
local pstor_custom = 3
local pstor_true = 4
local pstor_false = 5
local pstor_table = 6
local pstor_end_table = 7
local pstor_types = {
	['boolean'] = true,
	['string'] = true,
	['number'] = true,
	['table'] = true,
	['userdata'] = true
}

--------------------
-- Вернет ид актора, если переменной нет в таблице tabl_netpda_varnames
-- быстрее (чтобы не перебирать таблицу) - только указывать запись конкретной переменной на ПДА
local function get_pda()
	return netpacket_pda_create.create_pda()
end

function get_pda_id(var_name,action)
	if tabl_netpda_varnames[var_name] == true then
		return get_pda()
	end
    return 0
end
--------------------
function pstor_store(obj, varname, val)
	if (obj == nil) then return end
	
	local st = db.storage[(tabl_netpda_varnames[varname] and get_pda()) or (obj and obj:id()) or 0]

	if st then
		local ps = st.pstor
		if ps == nil then
			ps = {}; st.pstor = ps
		end
		if val==nil then
			ps[varname] = nil
		elseif pstor_types[type(val)] then
			ps[varname] = val
		else
			abort( "[xr_logic.pstor_store]: invalid type: %s [%s]", type(val), varname )
		end
	else
		abort( "[xr_logic.pstor_store]: [%s = %s] no storage for object [%s] !", tostring(varname), tostring(val), (obj and obj:name() or "<nil>") )
	end
end
------------------------------

function pstor_retrieve(obj, varname, defval, delvar)
	if (obj == nil) then return nil end

	local npc_id = (tabl_netpda_varnames[varname] and get_pda())
		or (obj and obj:id()) or 0

	if db.storage[npc_id].pstor ~= nil then
		local val = db.storage[npc_id].pstor[varname]
		if val ~= nil then
			if delvar then
				db.storage[npc_id].pstor[varname] = nil
			end
			return val
		end
	end

	return defval
end

function pstor_get_custom(obj, classname, varname)
	local npc_id = (tabl_netpda_varnames[varname] and get_pda())
		or (obj and obj:id()) or 0
	local pstor = db.storage[npc_id].pstor
	if pstor == nil then
		pstor = {}
		db.storage[npc_id].pstor = pstor
	end
	local val = pstor[varname]
	if val == nil then
		pstor[varname] = pstor_custom_impl[classname]()
		val = pstor[varname]
	end
	if val ~= nil then
		return val.st
	end
	return nil
end

function pstor_clear_custom(obj, varname)
	local obj_id = (tabl_netpda_varnames[varname] and get_pda())
		or (obj and obj:id()) or 0
	db.storage[obj_id].pstor[varname] = nil
end

function save_pstor_table(pk, tbl, obj)
	local tp
	for k, v in pairs(tbl) do
		if v == true then
			pk:w_u8(pstor_true)
		elseif v == false then
			pk:w_u8(pstor_false)
		else
			tp = type(v)
			if tp == "number" then
				pk:w_u8(pstor_number)
				pk:w_float(v)
			elseif tp == "string" then
				pk:w_u8(pstor_string)
				pk:w_stringZ(v)
			elseif tp == "table" then
				pk:w_u8(pstor_table)
				xr_logic.save_pstor_table(pk, v, obj)
			elseif tp == "userdata" then
				if v.classname and pstor_custom_impl[v.classname] then
					pk:w_u8(pstor_custom)
					pk:w_stringZ(v.classname)
					v:save(pk)
				else
					abort("[xr_logic.save_pstor_table] object %s: attempt to save unknown userdata, variable name = %s",
						obj:name(), k)
				end
			else
				abort("[xr_logic.save_pstor_table] object %s: not registered type '%s' encountered [ %s :: %s ]",
					obj:name(), tv, k, utils.to_str(v))
			end
		end
	--	if type(k) == "number" then k = string.char(1)..k end
		pk:w_stringZ( tostring(k) )
	end
	pk:w_u8(pstor_end_table)
end

function load_pstor_table(pk, tbl, obj)
	local k, v, n
	while true do
		n = pk:r_u8()
		if n == pstor_end_table then
			return tbl
		else
			if n == pstor_true then
				v = true
			elseif n == pstor_false then
				v = false
			elseif n == pstor_number then
				v = pk:r_float()
			elseif n == pstor_string then
				v = pk:r_stringZ()
			elseif n == pstor_table then
				v = {}
				xr_logic.load_pstor_table(pk, v, obj)
			elseif n == pstor_custom then
				v = pstor_custom_impl[pk:r_stringZ()]()
				v:load(pk)
			else
				abort("У объекта [%s] повреждён пстор, этим сохранением нельзя пользоваться - удалите его и переиграйте с предыдущего.", obj:name())
				v = nil
			end
			k = pk:r_stringZ()
		--	if k:sub(1,1):byte() == 1 then k = tonumber(k:sub(2)) end
			tbl[tonumber(k) or k] = v
		end
	end
end

function pstor_save_all(obj, packet)
	local npc_id = obj:id()
	local pstor = db.storage[npc_id].pstor
	if not pstor then
		pstor = {}
		db.storage[npc_id].pstor = pstor
	end
	save_pstor_table(packet, pstor, obj)
end

function pstor_load_all(obj, reader)
	local npc_id = obj:id()
	local pstor = db.storage[npc_id].pstor
	if not pstor then
		pstor = {}
		db.storage[npc_id].pstor = pstor
	end
	if (not db.actor) and npc_id ~= 0 then
		abort("Не создан актор. Возможно, синтаксическая ошибка в bind_actor.script")
	end

	load_pstor_table(reader, pstor, obj)
--	if npc_id == 0 or npc_id==get_pda() then
--		log("~ pstor_load_all: %s", obj:name())
--		table.print(pstor)
--	end
end

function save_obj(obj, packet)
	local npc_id = obj:id()
	local st = db.storage[npc_id]

	-- сообщение по побившейся логике физобъектов и вертолетов
	local s_ini = obj:spawn_ini()
	if (not st.ini_filename) and s_ini and logic_not_empty(obj, s_ini) then
		if obj:clsid() == clsid.script_phys or obj:clsid() == clsid.script_heli
		--	or ((IAmAStalker[obj:clsid()] or IAmAMonster[obj:clsid()]) and obj:alive())
		then
			abort("У объекта '%s' повисла логика. Удалите созданное только что сохранение и переиграйте с предыдущего", obj:name())
			if amk.load_variable("no_save", false) == false and not db.debug then
				amk.save_variable("no_save", true)
			--	xr_timers.start_real_timer("zonedocs_gg_kill",3,0)
			end
		end
	end

	packet:w_stringZ(st.ini_filename or "")
	packet:w_stringZ(st.section_logic or "")
	packet:w_stringZ(st.active_section or "")
	packet:w_stringZ(st.gulag_name or "")

	save_logic(obj, packet)

	if st.active_scheme then
		issue_event(obj, db.storage[npc_id][st.active_scheme], "save")
	end

	pstor_save_all(obj, packet)
end

function load_obj(obj, reader)
--  printf("load_obj: obj:name()='%s'", obj:name())
	local npc_id = obj:id()
	local st = db.storage[npc_id]

	local s = reader:r_stringZ()
	if s == "" then st.loaded_ini_filename = nil
	else st.loaded_ini_filename = s end

	s = reader:r_stringZ()
	if s == "" then st.loaded_section_logic = nil
	else st.loaded_section_logic = s end

	s = reader:r_stringZ()
	if s == "" then
		-- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
		-- При этом реальная active_section станет равной nil.
		st.loaded_active_section = "nil"
	else st.loaded_active_section = s end

	s = reader:r_stringZ()
	if s == "" then st.loaded_gulag_name = nil
	else st.loaded_gulag_name = s end

	load_logic(obj, reader)
	pstor_load_all(obj, reader)
end

function get_customdata_or_ini_file(npc, filename)
--  printf( "get_customdata_or_ini_file: filename=%s", filename )
	if filename == "<customdata>" then
		local ini = npc:spawn_ini()
		if ini then
			return ini
		else
			return ini_file([[scripts\dummy.ltx]])
		end
	elseif string.find( filename, "*" ) == 1 then
		-- динамический ltx
		local p = string.find( filename, "*", 2 )
		return gulag_tasks.loadLtx( string.sub(filename, 2, p-1), string.sub(filename, p+1) )
	else
		return ini_file(filename)
	end
end

function initialize_obj(obj, st, loaded, actor, stype, inifile)
  if not loaded then
    local ini_filename = inifile or "<customdata>"
    local ini = get_customdata_or_ini_file(obj, ini_filename)
    ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, "logic", nil)
    local sect = xr_logic.determine_section_to_activate(obj, ini, "logic", actor)
    xr_logic.activate_by_section(obj, ini, sect, false)
  else
    local ini_filename = st.loaded_ini_filename
    if ini_filename then
      local ini = get_customdata_or_ini_file(obj, ini_filename)
      ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, st.loaded_section_logic, st.loaded_gulag_name)
      printf( "initialize_obj: loaded" )
      xr_logic.activate_by_section(obj, ini, st.loaded_active_section, true)
    end

--    if st.active_scheme then
--      issue_event(obj, db.storage[obj:id()][st.active_scheme], "load")
--    end
  end
end

-- у объекта есть "непустая" логика
function logic_not_empty(npc, ini)
	return ini:section_exist("logic") and (
		ini:line_exist("logic", "cfg") or (ini:line_exist("logic", "active") and ini:r_string("logic", "active") ~= "nil")
	)
end

